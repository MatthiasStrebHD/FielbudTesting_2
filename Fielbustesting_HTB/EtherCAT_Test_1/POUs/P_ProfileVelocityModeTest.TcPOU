<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="P_ProfileVelocityModeTest" Id="{07c0302c-0cb9-47b1-8de2-45d586cdd84b}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM P_ProfileVelocityModeTest
//general handling
VAR
	bStartTestOfNewDrive			: BOOL;//starts new test
	bRestartTest					: BOOL;//restart if single test failed
	bManuallyRestoreDefaultValues	: BOOL;
	bError							: BOOL := FALSE;//Error handling
	bAckError						: BOOL;//Error handling
	bStopMotor						: BOOL;//Error handling
END_VAR

//test case success indication variables
VAR
	bSingleTestFailed				: BOOL := FALSE;
	
	bObject60FFtested 				: BOOL := FALSE;//target velocity
	bObject606Btested 				: BOOL := FALSE;//velocity demand value
	bObject6043tested				: BOOL := FALSE;//test case success indication variables
	bObject6046tested				: BOOL := FALSE;//test case success indication variables
	bObject6048tested				: BOOL := FALSE;//test case success indication variables
	bObject6049tested				: BOOL := FALSE;//test case success indication variables
	
	bTestBasicOperation_Success		: BOOL := FALSE;//test case success indication variables
	bTestAccel_Success				: BOOL := FALSE;//test case success indication variables	
	bTestDecel_Success				: BOOL := FALSE;//test case success indication variables
	bTestLimits_Success				: BOOL := FALSE;//test case success indication variables
	
	bTestBasicOperation_Failed		: BOOL := FALSE;
	bTestAccel_Failed				: BOOL := FALSE;
	bTestDecel_Failed				: BOOL := FALSE;
	bTestLimits_Failed				: BOOL := FALSE;
	
	bMaxLimitTest_Success			: BOOL := FALSE; //helper for limit
	bMinLimitTest_Success			: BOOL := FALSE; //helper for limit
	bMaxLimitTest_Failed			: BOOL := FALSE; //helper for limit
	bMinLimitTest_Failed			: BOOL := FALSE; //helper for limit	
END_VAR

//relevant parameters for test options
VAR
	fToleranceLimit					: REAL := 0.1; // 10% tolerance
	fToleranceAccDec				: REAL := 0.05; // 5% tolerance
	fToleranceBasicOp				: REAL := 0.02; // 2% tolerance
	nDeltaSpeedRef					: DINT := 300; //speed reference for acc/dec
	nDeltaTimeRef					: DINT := 1; //time reference for acc/dec
	nMinLimitRef					: DINT := 200; //testing this minimum velocity limit
	nMaxLimitRef					: DINT := 1000; //testing this maximum velocity limit	
END_VAR

// default values will be deliberately changed. Persistent variables keep their values also at shutdown of PLC, see https://infosys.beckhoff.com/index.php?content=../content/1031/tc3_plc_intro/2526557579.html&id=
// pressing "restart in run modus" will NOT clear these values!
VAR PERSISTENT
	nDefaultVelocityWindow			: DINT;
	nDefaultVelocityWindowTime		: DINT;
END_VAR

// all variables
VAR	
	eTestMode: (WAIT_FOR_TEST, READ_DEFAULT_VALUES, WRITE_DEFAULT_VALUES, ERROR, STOP_DRIVE, 
				BASIC_OPERATION, TEST_ACCEL, TEST_DECEL, TEST_LIMITS); 
	step							: INT := 1;
	stepTestMode					: INT := 0; //start in idle mode
	
	bSetControlWord					: BOOL := TRUE;
	fbProfileVelocityMode			: ProfileVelocityMode;
	fbReadVariable					: FB_EcCoESdoRead;
	fbGetStatusword					: FB_EcCoeSdoRead;
	fbGetActualVelocity				: FB_EcCoeSdoRead;
	fbReadVelocityLimits1			: FB_EcCoeSdoRead;
	fbReadVelocityLimits2			: FB_EcCoeSdoRead;
	fbWriteVelocityLimits1			: FB_EcCoESdoWrite;
	fbWriteVelocityLimits2			: FB_EcCoESdoWrite;
	fbWriteVelocityWindow1			: FB_EcCoESdoWrite;
	fbWriteVelocityWindow2			: FB_EcCoESdoWrite;
	fbReadVelocityWindow1			: FB_EcCoeSdoRead;
	fbReadVelocityWindow2			: FB_EcCoeSdoRead;
	fbReadVelocityWindowTime1		: FB_EcCoeSdoRead;
	fbReadVelocityWindowTime2		: FB_EcCoeSdoRead;
	fbWriteVelocityWindowTime1		: FB_EcCoESdoWrite;
	fbWriteVelocityWindowTime2		: FB_EcCoESdoWrite;
	fbGetVelocityDemand				: FB_EcCoESdoRead;
	nTargetVelocity					: DINT := 50; //rpm
	nActualVelocity					: DINT;
	nStatusword						: UINT;
	nSpeed							: DINT;
	nTime							: DINT;
		
	bGetCurrentVelocity				: BOOL;
	bGetStatusword					: BOOL;
	bSetVelocity					: BOOL; 
	nTargetVelocityAfterLimit		: DINT;
	tTimeDec1						: TIME;
	tTimeDec2						: TIME;
	nAccMeasured					: REAL;
	nDecMeasured					: REAL;
	bIsAccelerating					: BOOL;
	bIsDecelerating					: BOOL;
	
	bDone							: BOOL;
	nDeltaVelocityTarget			: REAL;
	fDesiredAcceleration			: REAL;
	nVelocityDemandValue					: DINT;
	nVelocityMinLimit 				: DINT;
	nVelocityMaxLimit 				: DINT;
	bWriteDefaultValues				: BOOL;
	nDecVelocity					: DINT;
	fDesiredDeceleration			: REAL;
	bStopAfterLimitTest				: BOOL;

	tTimeout						: TON;
	tTimer							: TON;
	tGetStatusword					: TON;
	tWaitForCurrentVelocity			: TON;
	tTimeAcc1						: TIME;
	tTimeAcc2						: TIME;
	tDiff							: TIME;
	fTrigger						: F_TRIG;
	fFlag 							: F_TRIG;	
	fFlagDetectPVMFail				: F_TRIG;	
	bActivateTimer					: BOOL;
	bTest							: BOOL;
	bTargetVelocityReached			: BOOL;
	nVelocityWindow					: DINT;
	nVelocityWindowTime				: DINT;
	Index 							: WORD := 16#606C;
	Subindex						: BYTE;
	nValue							: DINT;
	bExecuteReadVariable			: BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF bTestBasicOperation_Failed OR bTestAccel_Failed OR bTestDecel_Failed OR bMinLimitTest_Failed OR bMaxLimitTest_Failed OR bTestLimits_Failed THEN
	bSingleTestFailed := TRUE;
ELSE bSingleTestFailed := FALSE;
END_IF

// timer for FB calls
tWaitForCurrentVelocity(IN := bGetCurrentVelocity, PT := T#10MS);
tGetStatusword(IN := bGetStatusword, PT := T#50MS);	
IF tGetStatusword.Q THEN
	bGetStatusword := FALSE;
ELSE
	bGetStatusword := TRUE;		
END_IF						
IF tWaitForCurrentVelocity.Q THEN
	bGetCurrentVelocity := FALSE;
ELSE
	bGetCurrentVelocity := TRUE;		
END_IF
// read FBs
fbGetStatusword(sNetId := GVL.sNetId,
				nSlaveAddr := GVL.nSlaveAddr,
				nIndex := 16#6041,
				nSubindex := 0,
				pDstBuf := ADR(nStatusWord),
				cbBufLen := SIZEOF(nStatusWord),
				bExecute := bGetStatusword);
				
fbGetActualVelocity(sNetId := GVL.sNetId,
					nSlaveAddr := GVL.nSlaveAddr,
					nIndex := 16#606C,
					nSubindex := 0,
					pDstBuf := ADR(nActualVelocity),
					cbBufLen := SIZEOF(nActualVelocity),
					bExecute := bGetCurrentVelocity);
					
fbReadVariable(sNetId := GVL.sNetId,
				nSlaveAddr := GVL.nSlaveAddr,
				nIndex := Index, //variable index
				nSubindex := Subindex,
				pDstBuf := ADR(nValue),
				cbBufLen := SIZEOF(nValue),
				bExecute := bExecuteReadVariable);
				
// profile velocity mode
fbProfileVelocityMode(sNetID := GVL.sNetId,
					nSlaveAddr := GVL.nSlaveAddr,
					nTargetVelocity := nTargetVelocity,
					bSetVelocity := bSetVelocity);

bTargetVelocityReached := nStatusword.10;// target velocity reached

//stop
IF bStopMotor THEN
	MAIN.Controlword := 0;
	eTestMode := WAIT_FOR_TEST;
	stepTestMode := 0;
END_IF


(*TEST SUITE*)	
//error detection
IF bError THEN
	MAIN.Controlword := 0;
	stepTestMode := 0;
	eTestMode := ERROR;
END_IF
// restore stored default values
IF bManuallyRestoreDefaultValues THEN
	eTestMode := WRITE_DEFAULT_VALUES;
END_IF

CASE eTestMode OF
	WAIT_FOR_TEST:
		tTimeout(IN := FALSE);
		bSetVelocity := FALSE;
		step := 1; //resetting general step counter for use within TestModes
		CASE stepTestMode OF
			0: //idle
				IF bRestartTest THEN //restart inside a test procedure
					GVL.bReset := TRUE;
					bRestartTest := FALSE; 
					bSetControlWord := TRUE;
					bTestBasicOperation_Failed := bTestAccel_Failed := bTestDecel_Failed := bMinLimitTest_Failed := bMaxLimitTest_Failed := bTestLimits_Failed := FALSE;
					stepTestMode := stepTestMode+1;
				END_IF
				IF bStartTestOfNewDrive THEN //start test of a new drive 
					GVL.bReset := TRUE;
					Reset();
					bSetControlWord := TRUE;
					bStartTestOfNewDrive := FALSE;
					eTestMode := READ_DEFAULT_VALUES;
				END_IF
		
			1: 
				IF bTestBasicOperation_Success THEN 
					stepTestMode := stepTestMode+1; 
					//bObject6043tested := TRUE;
				ELSE 
					eTestMode := BASIC_OPERATION; 
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT, msgFmtStr := 'Testing basic operation...', strArg := '');
				END_IF 				
			2: 				
				IF bTestAccel_Success THEN 
					stepTestMode := stepTestMode+1; 
					bObject6046tested := TRUE;
				ELSIF nActualVelocity = 0 THEN 
					eTestMode := TEST_ACCEL; 
					bSetControlWord := TRUE; 
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT, msgFmtStr := 'Testing acceleration...', strArg := '');
				END_IF 				
			3: 
				IF bTestDecel_Success THEN 
					stepTestMode := stepTestMode+1; 
					bObject6048tested := TRUE;
				ELSE 
					eTestMode := TEST_DECEL; 
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT, msgFmtStr := 'Testing deceleration...', strArg := '');
				END_IF
			4: 
				IF bTestLimits_Success THEN 
					stepTestMode := stepTestMode+1; 
					bObject6049tested := TRUE;
				ELSE 
					eTestMode := TEST_LIMITS; 
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT, msgFmtStr := 'Testing limits...', strArg := '');
				END_IF				
			
			5: //all tests successful
				MAIN.Controlword := 0;
				ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT, msgFmtStr := 'All tests successful!', strArg := '');
				stepTestMode := 0; //idle
		END_CASE	
	
		
	(* Error handling *)
	ERROR:
		bSetVelocity := FALSE;
		MAIN.Controlword := 0;
		bSetControlWord := FALSE;
		IF bAckError OR bRestartTest THEN
			bAckError := FALSE;
			bError := FALSE;
			
			eTestMode := WAIT_FOR_TEST;
			stepTestMode := 0;
		END_IF


	READ_DEFAULT_VALUES: 
		CASE step OF
			1: //read velocity window
				ReadVelocityWindow(nVelocityWindow := nDefaultVelocityWindow, bDone => bDone);
				IF bDone THEN
					step := step+1;
				END_IF
			2: //read velocity window time
				ReadVelocityWindowTime(nVelocityWindowTime := nDefaultVelocityWindowTime, bDone => bDone);
				IF bDone THEN
					step := step+1;
				END_IF				
			3: 
				eTestMode := WAIT_FOR_TEST;			
				ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT, msgFmtStr := 'Default values read.', strArg := '');
				stepTestMode := 1; //start test basic operation
		END_CASE
		
		
	WRITE_DEFAULT_VALUES: 
		CASE step OF
			1: //write velocity window
				WriteVelocityWindow(nVelocityWindow := nDefaultVelocityWindow, bDone => bDone);
				IF bDone THEN
					step := step+1;
				END_IF
			2: 
				ReadVelocityWindow(nVelocityWindow := nVelocityWindow, bDone => bDone);
				IF nVelocityWindow = nDefaultVelocityWindow AND bDone THEN
					step := step+1;
				END_IF
			3: //write velocity window time 
				WriteVelocityWindowTime(nVelocityWindowTime := nDefaultVelocityWindowTime, bDone => bDone);
				IF bDone THEN
					step := step+1;
				END_IF	
			4:
				ReadVelocityWindowTime(nVelocityWindowTime := nDefaultVelocityWindowTime, bDone => bDone);
				IF nVelocityWindowTime = nDefaultVelocityWindowTime AND bDone THEN
					step := step+1;
				END_IF
			
			5: 
				eTestMode := WAIT_FOR_TEST;	
				ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'Default values restored. Velocity window and velocity window time',
					strArg := '');		
				IF bSingleTestFailed THEN
					bError := TRUE;
				END_IF
				//TODO delete
				IF bStopAfterLimitTest THEN
					bStopAfterLimitTest := FALSE;
					eTestMode := STOP_DRIVE;
				END_IF
				bManuallyRestoreDefaultValues := FALSE;
		END_CASE
		
		
	STOP_DRIVE:
		step := 1;
		nTargetVelocity := 0;
		bSetVelocity := TRUE;
		IF nActualVelocity = 0 THEN
			IF bWriteDefaultValues THEN
				bWriteDefaultValues := FALSE;
				eTestMode := WRITE_DEFAULT_VALUES;
			ELSE
				eTestMode := WAIT_FOR_TEST;
			END_IF
		END_IF
	
	(* Test basic operation *)
	BASIC_OPERATION:
		fFlagDetectPVMFail(CLK := bTargetVelocityReached); //detect if drive leaves velocity window (#606D)
		tTimer(IN := bActivateTimer, PT := T#3S); //time the drive should hold the target velocity 
		tTimeout(IN := TRUE, PT := T#15S);
		CASE step OF
		1:	
			nTargetVelocity := 1000; // rpm
			bSetVelocity := TRUE;
			IF NOT fbProfileVelocityMode.bBusy THEN //now velocity is set
				step := step+1;
				// call fbReadVariable
				Index := 16#60FF;
				Subindex := 0;
				bExecuteReadVariable := TRUE;
			END_IF
		2:
			IF nValue = nTargetVelocity THEN
				bExecuteReadVariable := FALSE;
				bObject60FFtested := TRUE;
				step := step+1;
			END_IF	
		3: //check if motor leaves the velocity window
			IF bTargetVelocityReached THEN
				bActivateTimer := TRUE;
				step := step+1;
			END_IF
		4:
			IF tTimer.Q THEN
				bActivateTimer := FALSE;
				step := step+1;
			END_IF
		5:
			IF fFlagDetectPVMFail.Q THEN // then motor didn't leave velocity window
				bError := TRUE;
				bTestBasicOperation_Failed := TRUE;
				ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'Timeout. Basic operation test failed.',
					strArg := '');
			ELSE
				bTestBasicOperation_Success := TRUE;
				step := step+1;								
				ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'Basic operation test success.',
					strArg := '');				
			END_IF				
			step := step+1;
		6: 
			// call fbReadVariable
			Index := 16#606C;
			Subindex := 0;
			bExecuteReadVariable := TRUE;
			step := step+1;
		7: 
			IF nValue = nTargetVelocity THEN
				bExecuteReadVariable := FALSE;
				bObject606Btested := TRUE;
				step := step+1;
			END_IF
		
		8:	//stop motor
			eTestMode := STOP_DRIVE;
		END_CASE
		
		//Error handling in wait_for_test
		IF tTimeout.Q THEN
			bTestBasicOperation_Failed := TRUE;
			bError := TRUE;
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
				msgFmtStr := 'Timeout. Basic operation test failed.',
				strArg := '');
		END_IF

	
//	(* Test acceleration target *)
//	TEST_ACCEL:
//		tTimeout(IN := TRUE, PT := T#10S); 
//		CASE step OF
//			1: //set acceleration values
//				WriteAcc(nDeltaSpeedRef := nDeltaSpeedRef, nDeltaTimeRef := nDeltaTimeRef, bDone => bDone);
//				IF bDone THEN
//					step := step+1;
//				END_IF
				
//			2: //read acceleration
//				ReadAcc(nDeltaSpeed := nSpeed, nDeltaTime := nTime, bDone => bDone); 
//				IF nSpeed = nDeltaSpeedRef AND nTime = nDeltaTimeRef AND bDone THEN //Acceleration values were set correctly
//					step := step+1;
//				END_IF
				
//			3: //set drive to TargetVelocity and measure acceleration time
//				nTargetVelocity := 2000;
//				nDeltaVelocityTarget := 0.995*TO_REAL(nTargetVelocity); //needs to be a little lower than target due to acc ramping
//				fDesiredAcceleration := TO_REAL(nDeltaSpeedRef/nDeltaTimeRef); // acc reference
				
//				bSetVelocity := TRUE;
//				fbVelocityMode(sNetID := GVL.sNetId,
//							nSlaveAddr := GVL.nSlaveAddr,
//							nTargetVelocity := nTargetVelocity,
//							bSetVelocity := bSetVelocity,
//							nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
//				fTrigger(CLK := fbVelocityMode.bBusy);
//				IF fTrigger.Q THEN
//					tTimeAcc1 := TIME();
//					step := step+1;
//				END_IF
			
//			4:
//				tTimer(IN:=TRUE, PT:=T#50MS);
//				IF tTimer.Q THEN
//					tTimer(IN:=FALSE);
//					step := step+1;
//				END_IF
				
//			5:
//				IF TO_REAL(nActualVelocity) >= nDeltaVelocityTarget THEN 
//					tTimeAcc2 := TIME();
//					tDiff := tTimeAcc2 - tTimeAcc1; //time difference of drive to reach nSpeedRef
//					nAccMeasured := TO_REAL(nActualVelocity*1000/TIME_TO_DINT(tDiff)); //time in ms
//					step := step+1;
//				END_IF

//			6: //validate result
//				IF  nAccMeasured > ((1-fToleranceAccDec)*fDesiredAcceleration) 
//				AND nAccMeasured < ((1+fToleranceAccDec)*fDesiredAcceleration) THEN //within range of tolerance: default 5%
//					bTestAccel_Success := TRUE;
//					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
//					msgFmtStr := 'Acceleration test success.',
//					strArg := '');
//				ELSE
//					bTestAccel_Failed := TRUE;
//					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
//						msgFmtStr := 'Acceleration test failed. Motor acceleration not within range of reference values.',
//						strArg := '');
//				END_IF
//				bWriteDefaultValues := TRUE;
//				eTestMode := STOP_DRIVE; //stop and restore default variables
//		END_CASE
		
//		//Error handling timeout
//		IF tTimeout.Q THEN
//			eTestMode := WRITE_DEFAULT_VALUES; //restore default variables
//			bTestAccel_Failed := TRUE;
//			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
//				msgFmtStr := 'Acceleration test failed. Timeout.',
//				strArg := '');
//		END_IF
		
	
		
//(* Test acceleration target *)
//	TEST_DECEL:
//		tTimeout(IN := TRUE, PT := T#15S); 
//		CASE step OF
//			1: //set deceleration values
//				WriteDec(nDeltaSpeedRef := nDeltaSpeedRef, nDeltaTimeRef := nDeltaTimeRef, bDone => bDone);
//				IF bDone THEN
//					step := step+1;
//				END_IF
				
//			2: //read deceleration
//				ReadDec(nDeltaSpeed := nSpeed, nDeltaTime := nTime, bDone => bDone); 
//				IF nSpeed = nDeltaSpeedRef AND nTime = nDeltaTimeRef AND bDone THEN //Acceleration values were set correctly
//					step := step+1;
//				END_IF
				
//			3: //set drive to velocity
//				nTargetVelocity := 1500;
//				nDecVelocity := nTargetVelocity;	
//				fDesiredDeceleration := TO_REAL(nDeltaSpeedRef/nDeltaTimeRef); // dec reference		
//				bSetVelocity := TRUE;
//				fbVelocityMode(sNetID := GVL.sNetId,
//							nSlaveAddr := GVL.nSlaveAddr,
//							nTargetVelocity := nTargetVelocity,
//							bSetVelocity := bSetVelocity,
//							nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
//				tTimer(IN:=TRUE, PT:=T#500MS);
//				IF tTimer.Q THEN
//					tTimer(IN:=FALSE);
//					step := step+1;
//				END_IF
			
//			4:
//				IF nActualVelocity > 0.99*nTargetVelocityAfterLimit THEN 
//					nTargetVelocity := 0;
//					step := step+1;
//				END_IF

//			5: //test run of drive for validation of deceleration 
//				bSetVelocity := TRUE;
//				fbVelocityMode(sNetID := GVL.sNetId,
//							nSlaveAddr := GVL.nSlaveAddr,
//							nTargetVelocity := nTargetVelocity,
//							bSetVelocity := bSetVelocity,
//							nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
//				fTrigger(CLK := fbVelocityMode.bBusy);
//				IF fTrigger.Q THEN
//					tTimeDec1 := TIME();
//					step := step+1;
//				END_IF
				
//			6:
//				IF nActualVelocity = nTargetVelocity THEN
//					tTimeDec2 := TIME();
//					tDiff := tTimeDec2 - tTimeDec1; //time difference of drive to decelerate
//					nDecMeasured := TO_REAL(nDecVelocity*1000/TIME_TO_DINT(tDiff));
//					step := step+1;
//				END_IF
			
//			7:	//validation
//				IF  nDecMeasured > ((1-fToleranceAccDec)*fDesiredDeceleration) 
//				AND nDecMeasured < ((1+fToleranceAccDec)*fDesiredDeceleration) THEN //within range of tolerance: default 5%
//					bTestDecel_Success := TRUE;
//					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
//					msgFmtStr := 'Deceleration test success.',
//					strArg := '');
//				ELSE
//					bTestDecel_Failed := TRUE;
//					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_WARN,
//						msgFmtStr := 'Deceleration test failed. Motor deceleration not within range of reference values.',
//						strArg := '');
//				END_IF
//				bWriteDefaultValues := TRUE;
//				eTestMode := STOP_DRIVE; //stop and restore default variables
//		END_CASE
		
//		//Error handling timeout
//		IF tTimeout.Q THEN
//			eTestMode := WRITE_DEFAULT_VALUES; //restore default variables
//			bTestDecel_Failed := TRUE;
//			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_WARN,
//				msgFmtStr := 'Deceleration test failed. Timeout.',
//				strArg := '');
//		END_IF
		

	
////	(* Test velocity limtis *)
//	TEST_LIMITS: 
//		tTimeout(IN:=TRUE, PT:=T#15S);
//		CASE step OF
//			1: 
//				nTargetVelocity := 2000;
//				WriteVelocityLimits(nVelocityMinLimit := nMinLimitRef, nVelocityMaxLimit := nMaxLimitRef, bDone => bDone);
//				IF bDone THEN
//					step := step+1;
//				END_IF
				
//			2: //test max limit
//				bSetVelocity := TRUE;
//				fbVelocityMode(sNetID := GVL.sNetId,
//							nSlaveAddr := GVL.nSlaveAddr,
//							nTargetVelocity := nTargetVelocity,
//							bSetVelocity := bSetVelocity,
//							nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
//				IF NOT fbVelocityMode.bBusy THEN
//					bIsAccelerating := TRUE;
//					step := step+1;
//				END_IF
			
//			3:
//				tTimer(IN := bIsAccelerating, PT := T#3S); //run for x seconds
//				IF tTimer.Q THEN 
//					tTimer(IN:=FALSE);
//					step := step+1;
//				END_IF
			
//			4:
//				IF TO_REAL(nActualVelocity) > ((1+fToleranceLimit)*TO_REAL(nMaxLimitRef))(* 10% overshot accounted *) THEN 
//					bMaxLimitTest_Failed := TRUE;
//					eTestMode := WRITE_DEFAULT_VALUES;
//					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_WARN,
//						msgFmtStr := 'Max limit test failed.',
//						strArg := '');			
//				ELSE
//					bMaxLimitTest_Success := TRUE;
//					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
//						msgFmtStr := 'Max limit test success.',
//						strArg := '');
//					step := step+1;
//				END_IF
//				bIsAccelerating := FALSE;
//				nTargetVelocity := 0;
				
//			5: //test min limit
//				bSetVelocity := TRUE;
//				fbVelocityMode(sNetID := GVL.sNetId,
//							nSlaveAddr := GVL.nSlaveAddr,
//							nTargetVelocity := nTargetVelocity,
//							bSetVelocity := bSetVelocity,
//							nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
//				IF NOT fbVelocityMode.bBusy THEN
//					bIsDecelerating := TRUE;
//					step := step+1;
//				END_IF
								
//			6:
//				tTimer(IN := bIsDecelerating, PT := T#3S); //run for x seconds
//				IF tTimer.Q THEN 
//					tTimer(IN:=FALSE);
//					step := step+1;
//				END_IF
			
//			7:
//				// a way for dynamic time determination
////				fTimeFaktor := DINT_TO_REAL((nActualVelocity-nTargetVelocity)/nSpeedDec); 
////				tDecTime := REAL_TO_TIME(2000+fTimeFaktor * nDefaultDecTime*1000); //acceleration time, min 2s
////				tTimer(IN := bIsDecelerating, PT := tDecTime);
//				IF TO_REAL(nActualVelocity) < ((1-fToleranceLimit)*TO_REAL(nMinLimitRef))(*10% overshot accounted*) THEN 
//					bMinLimitTest_Failed := TRUE;
//					eTestMode := WRITE_DEFAULT_VALUES;
//					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_WARN,
//						msgFmtStr := 'Min limit test failed.',
//						strArg := '');										
//				ELSE //time at witch the drive would be on targetvelocity without limit acitve
//					bMinLimitTest_Success := TRUE;
//					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
//						msgFmtStr := 'Min limit test success.',
//						strArg := '');
//					step := step+1;
//				END_IF
//				bIsDecelerating := FALSE;
			
//			8:
//				IF bMinLimitTest_Success AND bMaxLimitTest_Success THEN
//					bTestLimits_Success := TRUE;
//					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
//						msgFmtStr := 'Limit test success.',
//						strArg := '');
//				ELSE
//					bTestLimits_Failed := TRUE;
//					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
//						msgFmtStr := 'Limit test failed.',
//						strArg := '');
//				END_IF
//				bStopAfterLimitTest := TRUE;
//				step := 1;
//				eTestMode := WRITE_DEFAULT_VALUES; //stop and restore default variables				
//		END_CASE

END_CASE

]]></ST>
    </Implementation>
    <Method Name="ReadVelocityWindow" Id="{1eb658a9-75d3-44e3-9c80-388c54a8b7b0}">
      <Declaration><![CDATA[METHOD ReadVelocityWindow : BOOL
VAR_IN_OUT
	nVelocityWindow	: DINT;
END_VAR
VAR_OUTPUT
	bDone			: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bDone := FALSE;
//IF bRead THEN
	fbReadVelocityWindow1(sNetId := GVL.sNetId,
				nSlaveAddr := GVL.nSlaveAddr,
				nIndex := 16#606D,
				nSubindex := 1, //delta speed
				pDstBuf := ADR(nVelocityWindow),
				cbBufLen := SIZEOF(nVelocityWindow),
				bExecute := TRUE);
	
//	fbReadVelocityWindow2(sNetId := GVL.sNetId,
//				nSlaveAddr := GVL.nSlaveAddr,
//				nIndex := 16#6048,
//				nSubindex := 2, //delta time
//				pDstBuf := ADR(nDeltaTime),
//				cbBufLen := SIZEOF(nDeltaTime),
//				bExecute := TRUE);
//END_IF
IF NOT fbReadVelocityWindow1.bBusy THEN// AND NOT fbReadVelocityWindow2.bBusy THEN
	fbReadVelocityWindow1(bExecute := FALSE); 
	//fbReadVelocityWindow2(bExecute := FALSE); 
	bDone := TRUE;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadVelocityWindowTime" Id="{eda21da2-00bb-45fd-9842-01ea9a9f790c}">
      <Declaration><![CDATA[METHOD ReadVelocityWindowTime : BOOL
VAR_IN_OUT
	nVelocityWindowTime 	: DINT;
END_VAR
VAR_OUTPUT
	bDone			: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bDone := FALSE;
fbReadVelocityWindowTime1(sNetId := GVL.sNetId,
			nSlaveAddr := GVL.nSlaveAddr,
			nIndex := 16#606E,
			nSubindex := 1, //delta speed
			pDstBuf := ADR(nVelocityWindowTime),
			cbBufLen := SIZEOF(nVelocityWindowTime),
			bExecute := TRUE);

//fbReadVelocityWindowTime2(sNetId := GVL.sNetId,
//			nSlaveAddr := GVL.nSlaveAddr,
//			nIndex := 16#6049,
//			nSubindex := 2, //delta time
//			pDstBuf := ADR(nDeltaTime),
//			cbBufLen := SIZEOF(nDeltaTime),
//			bExecute := TRUE);

IF NOT fbReadVelocityWindowTime1.bBusy THEN//AND NOT fbReadVelocityWindowTime2.bBusy THEN
	fbReadVelocityWindowTime1(bExecute := FALSE); 
	//fbReadVelocityWindowTime2(bExecute := FALSE); 
	bDone := TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reset" Id="{5842e7c0-e329-43cf-be2c-7a7de34c7882}">
      <Declaration><![CDATA[METHOD Reset : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[bObject6043tested				:= FALSE;
bObject6046tested				:= FALSE;
bObject6048tested				:= FALSE;
bObject6049tested				:= FALSE;

bTestBasicOperation_Success		:= FALSE;
bTestAccel_Success				:= FALSE;	
bTestDecel_Success				:= FALSE;
bTestLimits_Success				:= FALSE;

bTestBasicOperation_Failed		:= FALSE;
bTestAccel_Failed				:= FALSE;
bTestDecel_Failed				:= FALSE;
bTestLimits_Failed				:= FALSE;
bSingleTestFailed					:= FALSE;

bMaxLimitTest_Success			:= FALSE;
bMinLimitTest_Success			:= FALSE;
bMaxLimitTest_Failed			:= FALSE;
bMinLimitTest_Failed			:= FALSE;


]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteVelocityWindow" Id="{3855ec99-3891-4af6-b130-d7a316b00e97}">
      <Declaration><![CDATA[METHOD WriteVelocityWindow : BOOL
VAR_IN_OUT
	nVelocityWindow	: DINT;
END_VAR
VAR_OUTPUT
	bDone 			: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bDone := FALSE;
fbWriteVelocityWindow1(sNetId := GVL.sNetId,
		nSlaveAddr := GVL.nSlaveAddr,
		nIndex := 16#606D,
		nSubindex := 1, //delta speed
		pSrcBuf := ADR(nVelocityWindow),
		cbBufLen := SIZEOF(nVelocityWindow),
		bExecute := TRUE);	
			
//fbWriteVelocityWindow2(sNetId := GVL.sNetId,
//		nSlaveAddr := GVL.nSlaveAddr,
//		nIndex := 16#6048,
//		nSubindex := 2, //delta time
//		pSrcBuf := ADR(nDeltaTimeRef),
//		cbBufLen := SIZEOF(nDeltaTimeRef),
//		bExecute := TRUE);

IF NOT fbWriteVelocityWindow1.bBusy THEN//AND NOT fbWriteVelocityWindow2.bBusy THEN
	fbWriteVelocityWindow1(bExecute := FALSE); 
	//fbWriteVelocityWindow2(bExecute := FALSE); 
	bDone := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteVelocityWindowTime" Id="{8d2c4a85-0157-4ce8-9aef-611ca84cbf12}">
      <Declaration><![CDATA[METHOD WriteVelocityWindowTime : BOOL
VAR_IN_OUT
	nVelocityWindowTime 	: DINT;
END_VAR
VAR_OUTPUT
	bDone 			: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bDone := FALSE;
fbWriteVelocityWindowTime1(sNetId := GVL.sNetId,
		nSlaveAddr := GVL.nSlaveAddr,
		nIndex := 16#606E,
		nSubindex := 1, //delta speed
		pSrcBuf := ADR(nVelocityWindowTime),
		cbBufLen := SIZEOF(nVelocityWindowTime),
		bExecute := TRUE);	
			
//fbWriteVelocityWindowTime2(sNetId := GVL.sNetId,
//		nSlaveAddr := GVL.nSlaveAddr,
//		nIndex := 16#6049,
//		nSubindex := 2, //delta time
//		pSrcBuf := ADR(nDeltaTimeRef),
//		cbBufLen := SIZEOF(nDeltaTimeRef),
//		bExecute := TRUE);
			
IF NOT fbWriteVelocityWindowTime1.bBusy THEN// AND NOT fbWriteVelocityWindowTime2.bBusy THEN
	fbWriteVelocityWindowTime1(bExecute := FALSE); 
	//fbWriteVelocityWindowTime2(bExecute := FALSE); 
	bDone := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="P_ProfileVelocityModeTest">
      <LineId Id="13827" Count="230" />
      <LineId Id="14399" Count="0" />
      <LineId Id="14394" Count="2" />
      <LineId Id="14058" Count="0" />
      <LineId Id="14388" Count="3" />
      <LineId Id="14382" Count="0" />
      <LineId Id="14392" Count="0" />
      <LineId Id="14059" Count="28" />
      <LineId Id="14372" Count="3" />
      <LineId Id="14381" Count="0" />
      <LineId Id="14376" Count="0" />
      <LineId Id="14378" Count="0" />
      <LineId Id="14377" Count="0" />
      <LineId Id="14089" Count="282" />
      <LineId Id="829" Count="0" />
    </LineIds>
    <LineIds Name="P_ProfileVelocityModeTest.ReadVelocityWindow">
      <LineId Id="122" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="35" Count="4" />
      <LineId Id="41" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="64" Count="6" />
      <LineId Id="92" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="114" Count="1" />
      <LineId Id="125" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="100" Count="0" />
    </LineIds>
    <LineIds Name="P_ProfileVelocityModeTest.ReadVelocityWindowTime">
      <LineId Id="29" Count="0" />
      <LineId Id="31" Count="18" />
      <LineId Id="51" Count="1" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="P_ProfileVelocityModeTest.Reset">
      <LineId Id="6" Count="18" />
      <LineId Id="5" Count="0" />
      <LineId Id="25" Count="2" />
    </LineIds>
    <LineIds Name="P_ProfileVelocityModeTest.WriteVelocityWindow">
      <LineId Id="39" Count="0" />
      <LineId Id="7" Count="6" />
      <LineId Id="21" Count="0" />
      <LineId Id="15" Count="5" />
      <LineId Id="5" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="30" Count="2" />
      <LineId Id="38" Count="0" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="P_ProfileVelocityModeTest.WriteVelocityWindowTime">
      <LineId Id="35" Count="20" />
      <LineId Id="23" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>