<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="P_VelocityModeTest" Id="{20dbc57a-bcdc-4d5e-be58-5c2d209d0155}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM P_VelocityModeTest
VAR
	fbVelocityMode					: VelocityMode;
	fbGetStatusword					: FB_EcCoeSdoRead;
	fbGetActualVelocity				: FB_EcCoeSdoRead;
	fbGetVelocityLimitMax			: FB_EcCoeSdoRead;
	fbGetVelocityLimitMin			: FB_EcCoeSdoRead;
	fbReadDec						: FB_EcCoeSdoRead;
	fbWriteDec						: FB_EcCoESdoWrite;
	fbReadVelocityLimits			: FB_EcCoeSdoRead;
	fbWriteVelocityLimits			: FB_EcCoESdoWrite;
	fbWriteAcc1						: FB_EcCoESdoWrite;
	fbWriteAcc2						: FB_EcCoESdoWrite;
	fbReadAcc1		: FB_EcCoeSdoRead;
	fbReadAcc2		: FB_EcCoeSdoRead;
	nTargetVelocity					: DINT := 50; //rpm
	nActualVelocity					: DINT;
	nVelocityLimitMax				: DINT;
	nVelocityLimitMin				: DINT;
	nStatusword						: UINT;
	nDefaultSpeed					: DINT; // TODO make persistent: https://infosys.beckhoff.com/index.php?content=../content/1031/tc3_plc_intro/2526557579.html&id=
	nDefaultTime					: DINT;
	nSpeed							: DINT;
	nTime							: DINT;
	nAccRef							: DINT;
		
	tWaitForCurrentVelocity			: TON;
	bGetCurrentVelocity				: BOOL;
	tGetStatusword					: TON;
	bGetStatusword					: BOOL;
	bSetVelocity					: BOOL; 
	nTargetVelocityAfterLimit		: DINT;
	tTimeDec1: TIME;
	tTimeDec2: TIME;
	nAccMeasured: REAL;
	nDecMeasured: DINT;
	nMinLimitRef: DINT;
	nMaxLimitRef: DINT;
	nDefaultVelocityMinLimit: DINT;
	nDefaultVelocityMaxLimit: DINT;
	fTimeFaktor: REAL;
	tAccTime: TIME;
	tTimer: TON;
	bIsAccelerating: BOOL;
	nSpeedAcc: DINT;
	nTimeAcc: DINT;
	nSpeedDec: DINT;
	nTimeDec: DINT;
	bIsDecelerating: BOOL;
	tDecTime: TIME;
	
	bTimeout: BOOL;
	bReadAcc: BOOL;
	bWriteAcc: BOOL;
	bDone: BOOL;
	tempTimeDiff: DINT;
	nDeltaVelocityTarget: DINT;
	fDesiredAcceleration: REAL;
END_VAR

//relevant parameters
VAR
	fTolerance						: REAL := 0.05; // 5% tolerance
	nDeltaSpeedRef					: DINT := 300; //rpm
	nDeltaTimeRef					: DINT := 1;
	
END_VAR
//test case variables
VAR
	tTimeout				: TON;
	tTimeAcc1				: TIME;
	tTimeAcc2				: TIME;
	tDiff					: TIME;
	fTrigger				: F_TRIG;
	
	eTestMode				: (WAIT_FOR_TEST, ERROR, BASIC_OPERATION, TEST_ACCEL, TEST_DECEL, TEST_LIMITS); 
	step					: INT := 1;
	stepTestMode			: INT := 1;
END_VAR


//test case success indication variables
VAR
	bTestBasicOperation_Success		: BOOL := FALSE;
	bTestBasicOperation_Failed		: BOOL := FALSE;
	
	bTestAccel_Success				: BOOL := FALSE;
	bTestAccel_Failed				: BOOL := FALSE;
	
	bTestDecel_Success				: BOOL := FALSE;
	bTestDecel_Failed				: BOOL := FALSE;
	
	bMaxLimitTest_Success			: BOOL := FALSE; //helper for limit
	bMaxLimitTest_Failed			: BOOL := FALSE; //helper for limit
	bMinLimitTest_Success			: BOOL := FALSE; //helper for limit
	bMinLimitTest_Failed			: BOOL := FALSE; //helper for limit
	
	bTestLimits_Success				: BOOL := FALSE;
	bTestLimits_Failed				: BOOL := FALSE;
END_VAR

//Error handling
VAR
	bError							: BOOL := FALSE;
	bStopMotor						: BOOL;
	bSetControlWord					: BOOL := TRUE;
	bAckError						: BOOL;
	bRestartTest					: BOOL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[tWaitForCurrentVelocity(IN := bGetCurrentVelocity,
							PT := T#10MS);
tGetStatusword(IN := bGetStatusword,
					PT := T#500MS);	
							
IF tWaitForCurrentVelocity.Q THEN
	bGetCurrentVelocity := FALSE;
ELSE
	bGetCurrentVelocity := TRUE;		
END_IF
// read FBs
fbGetStatusword(sNetId := GVL.sNetId,
				nSlaveAddr := GVL.nSlaveAddr,
				nIndex := 16#6041,
				nSubindex := 0,
				pDstBuf := ADR(nStatusWord),
				cbBufLen := SIZEOF(nStatusWord),
				bExecute := bGetStatusword);
				
fbGetActualVelocity(sNetId := GVL.sNetId,
					nSlaveAddr := GVL.nSlaveAddr,
					nIndex := 16#6044,
					nSubindex := 0,
					pDstBuf := ADR(nActualVelocity),
					cbBufLen := SIZEOF(nActualVelocity),
					bExecute := bGetCurrentVelocity);

//write to motor
MAIN.Controlword.4 := bSetControlWord; //velocity demand value shall equal to ramp output value
MAIN.Controlword.5 := bSetControlWord; //ramp output value shall follow ramp input value
MAIN.Controlword.6 := bSetControlWord; //ramp input value shall accord with ramp reference

			
//stop
IF bStopMotor OR bError THEN
	MAIN.Controlword := 0;
	stepTestMode := 0;
END_IF


(*TEST SUITE*)	
//error detection
IF bError THEN
	eTestMode := ERROR;
END_IF

CASE eTestMode OF
	WAIT_FOR_TEST:
		CASE stepTestMode OF
			-1: //error handling
				eTestMode := ERROR;
			0: //idle
				IF bRestartTest THEN
					bRestartTest := FALSE;
					bSetControlWord := TRUE;
					stepTestMode := stepTestMode+1;
				END_IF				
			1: 
				IF bTestBasicOperation_Success THEN stepTestMode := stepTestMode+1; 
				ELSE eTestMode := BASIC_OPERATION; 
				END_IF 
			2: 				
				IF bTestAccel_Success THEN stepTestMode := stepTestMode+1; 
				ELSIF nActualVelocity = 0 THEN eTestMode := TEST_ACCEL; bSetControlWord := TRUE;
				END_IF 
			3: 
				IF bTestDecel_Success THEN stepTestMode := stepTestMode+1; 
				//ELSE eTestMode := TEST_DECEL;
				END_IF
			4: 
				IF bTestLimits_Success THEN stepTestMode := stepTestMode+1;
				ELSE eTestMode := TEST_LIMITS;
				END_IF
			
			5: //all tests successful
				ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'All tests successful!',
					strArg := '');
		END_CASE	
		step := 1; //resetting general step counter for use within TestModes
	
		
	(* Error handling *)
	ERROR:
		MAIN.Controlword := 0;
		bSetControlWord := FALSE;
		IF bAckError THEN
			bAckError := FALSE;
			bError := FALSE;
			
			eTestMode := WAIT_FOR_TEST;
			stepTestMode := 0;
		END_IF
		
		
	(* Test basic operation *)
	BASIC_OPERATION:
		CASE step OF
		1:
			nTargetVelocity := 300; //rpm
			bSetVelocity := TRUE;
			fbVelocityMode(sNetID := GVL.sNetId,
						nSlaveAddr := GVL.nSlaveAddr,
						nTargetVelocity := nTargetVelocity,
						bSetVelocity := bSetVelocity,
						nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
			IF NOT fbVelocityMode.bBusy THEN //now velocity is set
				step := step+1;
			END_IF
			
		2: 
			bTimeout := TRUE;
			tTimeout(IN := bTimeout, PT := T#15S);
			IF nActualVelocity > (0.98*nTargetVelocityAfterLimit) AND nActualVelocity < (1.02*nTargetVelocityAfterLimit) THEN // Vsoll = Vist
				step := step+1;
								
				ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'Basic operation test success.',
					strArg := '');
			END_IF	
			
		3:	//stop motor
			bSetVelocity := TRUE;
			fbVelocityMode(sNetID := GVL.sNetId,
						nSlaveAddr := GVL.nSlaveAddr,
						nTargetVelocity := 0,
						bSetVelocity := bSetVelocity,
						nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
						
			IF NOT fbVelocityMode.bBusy THEN
				bTestBasicOperation_Success := TRUE; //set success indication
				eTestMode := WAIT_FOR_TEST;
				bTimeout := FALSE;
			END_IF
		END_CASE
		
		//Error handling in wait_for_test
		IF tTimeout.Q THEN
			bTestBasicOperation_Failed := TRUE;
			bError := TRUE;
			bTimeout := FALSE;
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
				msgFmtStr := 'Basic operation test failed. Timeout.',
				strArg := '');
		END_IF

	
	(* Test acceleration target *)
	TEST_ACCEL:
		CASE step OF
			1: 
				bReadAcc := TRUE;
				step := step+1;
				
			2: //store acceleration values
				ReadAcc(bRead := bReadAcc, nDeltaSpeed := nDefaultSpeed, nDeltaTime := nDefaultTime, bDone => bDone);
				IF nDefaultSpeed <> 0 AND nDefaultTime <> 0 AND bDone THEN //safety
					bWriteAcc := TRUE;
					step := step+1;
				END_IF
				
			3: //set acceleration values
				WriteAcc(bWrite := bWriteAcc, nDeltaSpeedRef := nDeltaSpeedRef, nDeltaTimeRef := nDeltaTimeRef, bDone => bDone);
				IF bDone THEN
					bReadAcc := TRUE;
					step := step+1;
				END_IF
				
			4: 
				ReadAcc(bRead := bReadAcc, nDeltaSpeed := nSpeed, nDeltaTime := nTime, bDone => bDone); //read drive and check if acc was set correctly
				IF nSpeed = nDeltaSpeedRef AND nTime = nDeltaTimeRef AND bDone THEN //Acceleration values were set correctly
					step := step+1;
				END_IF
//				bTimeout := TRUE;
//				tTimeout(IN := bTimeout, PT := T#15S); //for next steps
				
			5: //set drive to TargetVelocity and measure acceleration time
				nTargetVelocity := 2000;
				nDeltaVelocityTarget := 1900; //needs to be a little lower than target
				fDesiredAcceleration := TO_REAL(nDeltaSpeedRef/nDeltaTimeRef); // acc reference
				
				bSetVelocity := TRUE;
				fbVelocityMode(sNetID := GVL.sNetId,
							nSlaveAddr := GVL.nSlaveAddr,
							nTargetVelocity := nTargetVelocity,
							bSetVelocity := bSetVelocity,
							nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
				fTrigger(CLK := fbVelocityMode.bBusy);
				IF fTrigger.Q THEN
					tTimeAcc1 := TIME();
				END_IF
				IF nActualVelocity >= nDeltaVelocityTarget THEN
					tTimeAcc2 := TIME();
					tDiff := tTimeAcc2 - tTimeAcc1; //time difference of drive to reach nSpeedRefa
					tempTimeDiff := TIME_TO_DINT(tDiff);
					nAccMeasured := TO_REAL(nActualVelocity*1000/TIME_TO_DINT(tDiff)); //time in ms
					step := step+1;
				END_IF

			6: //validate result
				IF nAccMeasured > ((1-fTolerance)*fDesiredAcceleration) AND nAccMeasured < ((1+fTolerance)*fDesiredAcceleration) THEN //within range of tolerance: default 5%
					bTestAccel_Success := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'Acceleration test success.',
					strArg := '');
				ELSE
					bTestAccel_Failed := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
						msgFmtStr := 'Acceleration test failed. Motor acceleration not within range of reference values.',
						strArg := '');
				END_IF
				bSetControlWord := FALSE; //stop motor
				bWriteAcc := TRUE;
				step := 99; //restore default variables
			
			99: //restore default variables
				WriteAcc(bWrite := bWriteAcc, nDeltaSpeedRef := nDefaultSpeed, nDeltaTimeRef := nDefaultTime, bDone => bDone);
				IF bDone THEN
					bReadAcc := TRUE;
					step := step+1;
				END_IF
			
			100:
				ReadAcc(bRead := bReadAcc, nDeltaSpeed := nSpeed, nDeltaTime := nTime, bDone => bDone); //check if acc was reset correctly
				IF nSpeed = nDefaultSpeed AND nTime = nDefaultTime AND bDone THEN //Acceleration values were set correctly to default values
					eTestMode := WAIT_FOR_TEST;
					bTimeout := FALSE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
						msgFmtStr := 'Default values restored.',
						strArg := '');
						
					IF bTestAccel_Failed THEN
						bError := TRUE;	
						IF tTimeout.Q THEN
							ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
								msgFmtStr := 'Acceleration test failed. Timeout.',
								strArg := '');
						END_IF					
					END_IF
				END_IF		
		END_CASE
		
		//Error handling timeout
		IF tTimeout.Q THEN
			step := 99; //restore default variables
			bWriteAcc := TRUE;
			bTestAccel_Failed := TRUE;
		END_IF
		
	
	(* Test deceleration target *)
	TEST_DECEL:
		CASE step OF
			1: //store deceleration values
				ReadDec(nDeltaSpeed => nDefaultSpeed, nDeltaTime => nDefaultTime);
				step := step+1;
				
			2: //set deceleration values
				WriteDec(nDeltaSpeedRef := nDeltaSpeedRef, nDeltaTimeRef := nDeltaTimeRef);
				ReadDec(nDeltaSpeed => nSpeed, nDeltaTime => nTime); //read drive deceleration
				IF nSpeed = nDeltaSpeedRef AND nTime = nDeltaTimeRef THEN //deceleration values were set correctly
					step := step+1;
				END_IF
				bTimeout := TRUE;
				tTimeout(IN := bTimeout, PT := T#15S);
				
			3: //speed machine up
				nTargetVelocity := 1500;
				bSetVelocity := TRUE;
				fbVelocityMode(sNetID := GVL.sNetId,
							nSlaveAddr := GVL.nSlaveAddr,
							nTargetVelocity := nTargetVelocity,
							bSetVelocity := bSetVelocity,
							nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
				IF nActualVelocity = nTargetVelocityAfterLimit THEN
					step := step+1;
				END_IF
				
			4: //test run of drive for validation of deceleration 
				nTargetVelocity := 0;
				bSetVelocity := TRUE;
				fbVelocityMode(sNetID := GVL.sNetId,
							nSlaveAddr := GVL.nSlaveAddr,
							nTargetVelocity := nTargetVelocity,
							bSetVelocity := bSetVelocity,
							nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
				fTrigger(CLK := fbVelocityMode.bBusy);
				IF fTrigger.Q THEN
					tTimeDec1 := TIME();
				END_IF
				IF nActualVelocity >= nDeltaSpeedRef THEN
					tTimeDec2 := TIME();
					tDiff := tTimeDec2 - tTimeDec1; //time difference of drive to decelerate
					nDecMeasured := (nTargetVelocity - nActualVelocity)/TIME_TO_DINT(tDiff);
					step := step+1;
				END_IF

			5: //validate result
				IF nDecMeasured > (0.9*nDeltaSpeedRef/nDeltaTimeRef) AND nDecMeasured < (1.1*nDeltaSpeedRef/nDeltaTimeRef) THEN //within range of 10% of desired time 
					bTestDecel_Success := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'Deceleration test success.',
					strArg := '');
				ELSE
					bTestDecel_Failed := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'Deceleration test failed. Motor deceleration not within range of reference values.',
					strArg := '');
				END_IF
				step := step+1;
			
			6: //set default variables back to standard
				WriteDec(nDeltaSpeedRef := nDefaultSpeed, nDeltaTimeRef := nDefaultTime);
				ReadDec(nDeltaSpeed => nSpeed, nDeltaTime => nTime); //read drive 
				IF nSpeed = nDefaultSpeed AND nTime = nDefaultTime THEN //Acceleration values were set correctly to default values
					eTestMode := WAIT_FOR_TEST;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
						msgFmtStr := 'Default values restored.',
						strArg := '');
						
					IF bTestAccel_Failed THEN
						bError := TRUE;	
						IF tTimeout.Q THEN
							ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
								msgFmtStr := 'Deceleration test failed. Timeout.',
								strArg := '');
						END_IF					
					END_IF
				END_IF		
		END_CASE
		
		//Error handling timeout
		IF tTimeout.Q THEN
			bTestDecel_Failed := TRUE;
			step := 6; //restore default values
		END_IF
	
	
	(* Test velocity limtis *)
	TEST_LIMITS: 
		// Limits were already stored in variables nVelocityLimitMax and -Min
		CASE step OF
			1: //read limits
				ReadVelocityLimits(nVelocityMinLimit => nDefaultVelocityMinLimit, nVelocityMaxLimit => nDefaultVelocityMaxLimit);
				//ReadAcc(nDeltaSpeed => nSpeedAcc, nDeltaTime => nTimeAcc);
				ReadDec(nDeltaSpeed => nSpeedDec, nDeltaTime => nTimeDec);
				step := step+1;

			2: //set limits
				nMinLimitRef := 200;
				nMaxLimitRef := 1000;
				WriteVelocityLimits(nMinLimitRef := nMinLimitRef, nMaxLimitRef := nMaxLimitRef);
				step := step+1;
				
			3: //test max limit
				nTargetVelocity := 2000;
				bSetVelocity := TRUE;
				fbVelocityMode(sNetID := GVL.sNetId,
							nSlaveAddr := GVL.nSlaveAddr,
							nTargetVelocity := nTargetVelocity,
							bSetVelocity := bSetVelocity,
							nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
				fTrigger(CLK := fbVelocityMode.bBusy);
				IF fTrigger.Q THEN
					bIsAccelerating := TRUE;
				END_IF
				fTimeFaktor := DINT_TO_REAL(nTargetVelocity/nSpeedAcc); 
				tAccTime := REAL_TO_TIME(2+fTimeFaktor * nTimeAcc); //acceleration time, min 2s
				tTimer(IN := bIsAccelerating, PT := tAccTime);
				//error if limit does not apply
				IF nActualVelocity > (1.1*nMaxLimitRef)(*10% overshot accounted*) OR nTargetVelocityAfterLimit <> nMaxLimitRef THEN 
					bMaxLimitTest_Failed := TRUE;
					bError := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
						msgFmtStr := 'Max limit test failed.',
						strArg := '');
						
					bIsAccelerating := FALSE;					
				END_IF
				
				IF tTimer.Q THEN //time at witch the drive would be on targetvelocity without limit acitve
					bIsAccelerating := FALSE;
					bMaxLimitTest_Success := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
						msgFmtStr := 'Max limit test success.',
						strArg := '');
					step := step+1;
				END_IF
				
			4: //test min limit
				nTargetVelocity := 0;
				bSetVelocity := TRUE;
				fbVelocityMode(sNetID := GVL.sNetId,
							nSlaveAddr := GVL.nSlaveAddr,
							nTargetVelocity := nTargetVelocity,
							bSetVelocity := bSetVelocity,
							nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
				fTrigger(CLK := fbVelocityMode.bBusy);
				IF fTrigger.Q THEN
					bIsDecelerating := TRUE;
				END_IF
				fTimeFaktor := DINT_TO_REAL((nActualVelocity-nTargetVelocity)/nSpeedDec); 
				tDecTime := REAL_TO_TIME(2+fTimeFaktor * nTimeDec); //acceleration time, min 2s
				tTimer(IN := bIsDecelerating, PT := tDecTime);
				//error if limit does not apply
				IF nActualVelocity < (0.9*nMinLimitRef)(*10% overshot accounted*) OR nTargetVelocityAfterLimit <> nMinLimitRef THEN 
					bMinLimitTest_Failed := TRUE;
					bError := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
						msgFmtStr := 'Min limit test failed.',
						strArg := '');
						
					bIsDecelerating := FALSE;					
				END_IF
				
				IF tTimer.Q THEN //time at witch the drive would be on targetvelocity without limit acitve
					bIsDecelerating := FALSE;
					bMinLimitTest_Success := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
						msgFmtStr := 'Min limit test success.',
						strArg := '');
					step := step+1;
				END_IF
			
			5:
				IF bMinLimitTest_Success AND bMaxLimitTest_Success THEN
					bTestLimits_Success := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
						msgFmtStr := 'Limit test success.',
						strArg := '');
				ELSE
					bTestLimits_Failed := TRUE;
					bError := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
						msgFmtStr := 'Limit test failed.',
						strArg := '');
				END_IF
				
		END_CASE

		



END_CASE













]]></ST>
    </Implementation>
    <Method Name="ReadAcc" Id="{82ba7047-c692-4533-849f-64295ad386ce}">
      <Declaration><![CDATA[METHOD ReadAcc : BOOL
VAR_IN_OUT
	nDeltaSpeed 	: DINT;
	nDeltaTime 		: DINT;
	bRead : BOOL;
END_VAR
VAR_OUTPUT
	bDone			: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bDone := FALSE;
IF bRead THEN
	fbReadAcc1(sNetId := GVL.sNetId,
				nSlaveAddr := GVL.nSlaveAddr,
				nIndex := 16#6048,
				nSubindex := 1, //delta speed
				pDstBuf := ADR(nDeltaSpeed),
				cbBufLen := SIZEOF(nDeltaSpeed),
				bExecute := TRUE);
	
	fbReadAcc2(sNetId := GVL.sNetId,
				nSlaveAddr := GVL.nSlaveAddr,
				nIndex := 16#6048,
				nSubindex := 2, //delta time
				pDstBuf := ADR(nDeltaTime),
				cbBufLen := SIZEOF(nDeltaTime),
				bExecute := TRUE);
END_IF
IF NOT fbReadAcc1.bBusy THEN
	fbReadAcc1(bExecute := FALSE); 
	fbReadAcc2(bExecute := FALSE); 
	bRead := FALSE;
	bDone := TRUE;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadDec" Id="{0557ec76-04b4-48e4-983c-7a14a262e28c}">
      <Declaration><![CDATA[METHOD ReadDec : BOOL
VAR_OUTPUT
	nDeltaSpeed : DINT;
	nDeltaTime 	: DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbReadDec(sNetId := GVL.sNetId,
				nSlaveAddr := GVL.nSlaveAddr,
				nIndex := 16#6049,
				nSubindex := 1, //delta speed
				pDstBuf := ADR(nDeltaSpeed),
				cbBufLen := SIZEOF(nDeltaSpeed),
				bExecute := TRUE);
				
fbReadDec(bExecute := FALSE);		
fbReadDec(sNetId := GVL.sNetId,
		nSlaveAddr := GVL.nSlaveAddr,
		nIndex := 16#6049,
		nSubindex := 2, //delta time
		pDstBuf := ADR(nDeltaTime),
		cbBufLen := SIZEOF(nDeltaTime),
		bExecute := TRUE);
fbReadDec(bExecute := FALSE);]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadVelocityLimits" Id="{6c32334b-6bd8-4afb-bf3f-0b7a4b269db0}">
      <Declaration><![CDATA[METHOD ReadVelocityLimits : BOOL
VAR_OUTPUT
	nVelocityMinLimit 	: DINT;
	nVelocityMaxLimit	: DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbReadVelocityLimits(sNetId := GVL.sNetId,
				nSlaveAddr := GVL.nSlaveAddr,
				nIndex := 16#6046,
				nSubindex := 1, //v_min
				pDstBuf := ADR(nVelocityMinLimit),
				cbBufLen := SIZEOF(nVelocityMinLimit),
				bExecute := TRUE);
				
fbReadVelocityLimits(bExecute := FALSE);		
fbReadVelocityLimits(sNetId := GVL.sNetId,
		nSlaveAddr := GVL.nSlaveAddr,
		nIndex := 16#6046,
		nSubindex := 2, //v_max
		pDstBuf := ADR(nVelocityMaxLimit),
		cbBufLen := SIZEOF(nVelocityMaxLimit),
		bExecute := TRUE);
fbReadVelocityLimits(bExecute := FALSE);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteAcc" Id="{1f9b3a2d-c64b-462e-ac9f-355827bafb38}">
      <Declaration><![CDATA[METHOD WriteAcc : BOOL
VAR_IN_OUT
	bWrite			: BOOL;
	nDeltaSpeedRef	: DINT;
	nDeltaTimeRef	: DINT;
END_VAR
VAR_OUTPUT
	bDone 			: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bDone := FALSE;
IF bWrite THEN
	fbWriteAcc1(sNetId := GVL.sNetId,
			nSlaveAddr := GVL.nSlaveAddr,
			nIndex := 16#6048,
			nSubindex := 1, //delta speed
			pSrcBuf := ADR(nDeltaSpeedRef),
			cbBufLen := SIZEOF(nDeltaSpeedRef),
			bExecute := TRUE);	
				
	fbWriteAcc2(sNetId := GVL.sNetId,
			nSlaveAddr := GVL.nSlaveAddr,
			nIndex := 16#6048,
			nSubindex := 2, //delta time
			pSrcBuf := ADR(nDeltaTimeRef),
			cbBufLen := SIZEOF(nDeltaTimeRef),
			bExecute := TRUE);
END_IF
IF NOT fbWriteAcc1.bBusy THEN
	fbWriteAcc1(bExecute := FALSE); 
	fbWriteAcc2(bExecute := FALSE); 
	bWrite := FALSE;
	bDone := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteDec" Id="{3e991329-f862-4f37-bc95-f9bc8420fcb7}">
      <Declaration><![CDATA[METHOD WriteDec : BOOL
VAR_INPUT
	nDeltaSpeedRef	: DINT;
	nDeltaTimeRef	: DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbWriteDec(sNetId := GVL.sNetId,
		nSlaveAddr := GVL.nSlaveAddr,
		nIndex := 16#6049,
		nSubindex := 1, //delta speed
		pSrcBuf := ADR(nDeltaSpeedRef),
		cbBufLen := SIZEOF(nDeltaSpeedRef),
		bExecute := TRUE);	
fbWriteDec(bExecute := FALSE);
			
fbWriteDec(sNetId := GVL.sNetId,
		nSlaveAddr := GVL.nSlaveAddr,
		nIndex := 16#6049,
		nSubindex := 2, //delta time
		pSrcBuf := ADR(nDeltaTimeRef),
		cbBufLen := SIZEOF(nDeltaTimeRef),
		bExecute := TRUE);
fbWriteDec(bExecute := FALSE);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteVelocityLimits" Id="{0e00e114-68f4-4bc1-81e9-c2d6f626f095}">
      <Declaration><![CDATA[METHOD WriteVelocityLimits : BOOL
VAR_INPUT
	nMinLimitRef : DINT;
	nMaxLimitRef : DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbWriteVelocityLimits(sNetId := GVL.sNetId,
		nSlaveAddr := GVL.nSlaveAddr,
		nIndex := 16#6046,
		nSubindex := 1, //v_min
		pSrcBuf := ADR(nMinLimitRef),
		cbBufLen := SIZEOF(nMinLimitRef),
		bExecute := TRUE);
fbWriteVelocityLimits(bExecute := FALSE);

fbWriteVelocityLimits(sNetId := GVL.sNetId,
		nSlaveAddr := GVL.nSlaveAddr,
		nIndex := 16#6046,
		nSubindex := 2, //v_max
		pSrcBuf := ADR(nMaxLimitRef),
		cbBufLen := SIZEOF(nMaxLimitRef),
		bExecute := TRUE);
fbWriteVelocityLimits(bExecute := FALSE);



]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="P_VelocityModeTest">
      <LineId Id="4740" Count="35" />
      <LineId Id="5490" Count="0" />
      <LineId Id="4776" Count="75" />
      <LineId Id="4855" Count="1" />
      <LineId Id="5499" Count="0" />
      <LineId Id="4858" Count="3" />
      <LineId Id="5491" Count="1" />
      <LineId Id="5494" Count="4" />
      <LineId Id="5493" Count="0" />
      <LineId Id="5506" Count="0" />
      <LineId Id="5502" Count="2" />
      <LineId Id="5501" Count="0" />
      <LineId Id="5505" Count="0" />
      <LineId Id="4862" Count="15" />
      <LineId Id="5166" Count="3" />
      <LineId Id="4878" Count="2" />
      <LineId Id="5270" Count="0" />
      <LineId Id="4881" Count="4" />
      <LineId Id="5373" Count="0" />
      <LineId Id="5482" Count="0" />
      <LineId Id="5374" Count="1" />
      <LineId Id="5172" Count="0" />
      <LineId Id="5171" Count="0" />
      <LineId Id="4886" Count="8" />
      <LineId Id="5507" Count="0" />
      <LineId Id="5509" Count="1" />
      <LineId Id="4895" Count="5" />
      <LineId Id="5162" Count="0" />
      <LineId Id="4902" Count="5" />
      <LineId Id="5487" Count="0" />
      <LineId Id="4908" Count="15" />
      <LineId Id="5486" Count="0" />
      <LineId Id="5513" Count="0" />
      <LineId Id="4924" Count="2" />
      <LineId Id="5376" Count="1" />
      <LineId Id="5484" Count="0" />
      <LineId Id="5378" Count="0" />
      <LineId Id="4927" Count="0" />
      <LineId Id="5379" Count="1" />
      <LineId Id="4928" Count="21" />
      <LineId Id="5483" Count="0" />
      <LineId Id="4950" Count="211" />
      <LineId Id="829" Count="0" />
    </LineIds>
    <LineIds Name="P_VelocityModeTest.ReadAcc">
      <LineId Id="122" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="35" Count="4" />
      <LineId Id="41" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="64" Count="6" />
      <LineId Id="92" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="114" Count="1" />
      <LineId Id="111" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="100" Count="0" />
    </LineIds>
    <LineIds Name="P_VelocityModeTest.ReadDec">
      <LineId Id="6" Count="14" />
      <LineId Id="5" Count="0" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="P_VelocityModeTest.ReadVelocityLimits">
      <LineId Id="109" Count="16" />
      <LineId Id="81" Count="0" />
    </LineIds>
    <LineIds Name="P_VelocityModeTest.WriteAcc">
      <LineId Id="39" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="7" Count="6" />
      <LineId Id="21" Count="0" />
      <LineId Id="15" Count="5" />
      <LineId Id="5" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="30" Count="3" />
      <LineId Id="38" Count="0" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="P_VelocityModeTest.WriteDec">
      <LineId Id="7" Count="7" />
      <LineId Id="21" Count="0" />
      <LineId Id="15" Count="5" />
      <LineId Id="5" Count="0" />
      <LineId Id="22" Count="1" />
    </LineIds>
    <LineIds Name="P_VelocityModeTest.WriteVelocityLimits">
      <LineId Id="12" Count="0" />
      <LineId Id="15" Count="4" />
      <LineId Id="5" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="26" Count="7" />
      <LineId Id="25" Count="0" />
      <LineId Id="21" Count="3" />
    </LineIds>
  </POU>
</TcPlcObject>