<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="P_VelocityModeTest" Id="{20dbc57a-bcdc-4d5e-be58-5c2d209d0155}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM P_VelocityModeTest
VAR
	fbVelocityMode					: VelocityMode;
	fbGetStatusword					: FB_EcCoeSdoRead;
	fbGetActualVelocity				: FB_EcCoeSdoRead;
	fbGetVelocityLimitMax			: FB_EcCoeSdoRead;
	fbGetVelocityLimitMin			: FB_EcCoeSdoRead;
	fbReadVelocityLimits1			: FB_EcCoeSdoRead;
	fbReadVelocityLimits2			: FB_EcCoeSdoRead;
	fbWriteVelocityLimits1			: FB_EcCoESdoWrite;
	fbWriteVelocityLimits2			: FB_EcCoESdoWrite;
	fbWriteAcc1						: FB_EcCoESdoWrite;
	fbWriteAcc2						: FB_EcCoESdoWrite;
	fbReadAcc1						: FB_EcCoeSdoRead;
	fbReadAcc2						: FB_EcCoeSdoRead;
	fbWriteDec1						: FB_EcCoESdoWrite;
	fbWriteDec2						: FB_EcCoESdoWrite;
	fbReadDec1						: FB_EcCoeSdoRead;
	fbReadDec2						: FB_EcCoeSdoRead;
	fbGetVelocityDemand				: FB_EcCoESdoRead;
	nTargetVelocity					: DINT := 50; //rpm
	nActualVelocity					: DINT;
	nStatusword						: UINT;
	nDefaultAccSpeed				: DINT; // TODO make persistent: https://infosys.beckhoff.com/index.php?content=../content/1031/tc3_plc_intro/2526557579.html&id=
	nDefaultDecSpeed				: DINT;
	nDefaultAccTime					: DINT;
	nDefaultDecTime					: DINT;
	nDefaultVelocityMinLimit		: DINT;
	nDefaultVelocityMaxLimit		: DINT;
	nSpeed							: DINT;
	nTime							: DINT;
	nAccRef							: DINT;
		
	tWaitForCurrentVelocity			: TON;
	bGetCurrentVelocity				: BOOL;
	tGetStatusword					: TON;
	bGetStatusword					: BOOL;
	bSetVelocity					: BOOL; 
	nTargetVelocityAfterLimit		: DINT;
	tTimeDec1: TIME;
	tTimeDec2: TIME;
	nAccMeasured: REAL;
	nDecMeasured: REAL;
	fTimeFaktor: REAL;
	tAccTime: TIME;
	tTimer: TON;
	bIsAccelerating: BOOL;
	nSpeedAcc: DINT;
	nTimeAcc: DINT;
	nSpeedDec: DINT;
	nTimeDec: DINT;
	bIsDecelerating: BOOL;
	tDecTime: TIME;
	
	bTimeout: BOOL;
	bReadAcc: BOOL;
	bWriteAcc: BOOL;
	bDone: BOOL;
	tempTimeDiff: DINT;
	nDeltaVelocityTarget: DINT;
	fDesiredAcceleration: REAL;
	fFlag : F_TRIG;
	nVelocityDemand: DINT;
	nVelocityMinLimit : DINT;
	nVelocityMaxLimit : DINT;
	bWriteDefaultValues: BOOL;
	nDecVelocity: DINT;
	fDesiredDeceleration: REAL;
	bStopAfterLimitTest: BOOL;
END_VAR

//relevant parameters
VAR
	fTolerance						: REAL := 0.05; // 5% tolerance
	nDeltaSpeedRef					: DINT := 300; //rpm
	nDeltaTimeRef					: DINT := 1;
	nMinLimitRef					: DINT := 200;
	nMaxLimitRef					: DINT := 1000;
	
END_VAR
//test case variables
VAR
	tTimeout				: TON;
	tTimeAcc1				: TIME;
	tTimeAcc2				: TIME;
	tDiff					: TIME;
	fTrigger				: F_TRIG;
	
	eTestMode				: (READ_DEFAULT_VALUES, WRITE_DEFAULT_VALUES, WAIT_FOR_TEST, ERROR, STOP_DRIVE, BASIC_OPERATION, TEST_ACCEL, TEST_DECEL, TEST_LIMITS); 
	step					: INT := 1;
	stepTestMode			: INT := 1;
END_VAR


//test case success indication variables
VAR
	bATestFailed					: BOOL := FALSE;
	bTestBasicOperation_Success		: BOOL := FALSE;
	bTestBasicOperation_Failed		: BOOL := FALSE;
	
	bTestAccel_Success				: BOOL := FALSE;
	bTestAccel_Failed				: BOOL := FALSE;
	
	bTestDecel_Success				: BOOL := FALSE;
	bTestDecel_Failed				: BOOL := FALSE;
	
	bMaxLimitTest_Success			: BOOL := FALSE; //helper for limit
	bMaxLimitTest_Failed			: BOOL := FALSE; //helper for limit
	bMinLimitTest_Success			: BOOL := FALSE; //helper for limit
	bMinLimitTest_Failed			: BOOL := FALSE; //helper for limit
	
	bTestLimits_Success				: BOOL := FALSE;
	bTestLimits_Failed				: BOOL := FALSE;
	
	bObject6043tested				: BOOL := FALSE;
	bObject6046tested				: BOOL := FALSE;
	bObject6048tested				: BOOL := FALSE;
	bObject6049tested				: BOOL := FALSE;
END_VAR

//Error handling
VAR
	bError							: BOOL := FALSE;
	bStopMotor						: BOOL;
	bSetControlWord					: BOOL := TRUE;
	bAckError						: BOOL;
	bRestartTest					: BOOL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF bTestBasicOperation_Failed OR bTestAccel_Failed OR bTestDecel_Failed OR bMinLimitTest_Failed OR bMaxLimitTest_Failed OR bTestLimits_Failed THEN
	bATestFailed := TRUE;
ELSE bATestFailed := FALSE;
END_IF


tWaitForCurrentVelocity(IN := bGetCurrentVelocity,
							PT := T#10MS);
tGetStatusword(IN := bGetStatusword,
					PT := T#500MS);	
							
IF tWaitForCurrentVelocity.Q THEN
	bGetCurrentVelocity := FALSE;
ELSE
	bGetCurrentVelocity := TRUE;		
END_IF
// read FBs
fbGetStatusword(sNetId := GVL.sNetId,
				nSlaveAddr := GVL.nSlaveAddr,
				nIndex := 16#6041,
				nSubindex := 0,
				pDstBuf := ADR(nStatusWord),
				cbBufLen := SIZEOF(nStatusWord),
				bExecute := bGetStatusword);
				
fbGetActualVelocity(sNetId := GVL.sNetId,
					nSlaveAddr := GVL.nSlaveAddr,
					nIndex := 16#6044,
					nSubindex := 0,
					pDstBuf := ADR(nActualVelocity),
					cbBufLen := SIZEOF(nActualVelocity),
					bExecute := bGetCurrentVelocity);

//write to motor
MAIN.Controlword.4 := bSetControlWord; //velocity demand value shall equal to ramp output value
MAIN.Controlword.5 := bSetControlWord; //ramp output value shall follow ramp input value
MAIN.Controlword.6 := bSetControlWord; //ramp input value shall accord with ramp reference

			
//stop
IF bStopMotor OR bError THEN
	MAIN.Controlword := 0;
	stepTestMode := 0;
END_IF


(*TEST SUITE*)	
//error detection
IF bError THEN
	eTestMode := ERROR;
END_IF

CASE eTestMode OF
	WAIT_FOR_TEST:
		tTimeout(IN := FALSE);
		step := 1; //resetting general step counter for use within TestModes
		CASE stepTestMode OF
			0: //idle
				IF bRestartTest THEN
					bRestartTest := FALSE;
					bSetControlWord := TRUE;
					stepTestMode := stepTestMode+1;
				END_IF		
		
			1: 
				IF bTestBasicOperation_Success THEN stepTestMode := stepTestMode+1; 
				ELSE eTestMode := BASIC_OPERATION; ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT, msgFmtStr := 'Testing basic operation...', strArg := '');
				END_IF 				
			2: 				
				IF bTestAccel_Success THEN stepTestMode := stepTestMode+1; 
				ELSIF nActualVelocity = 0 THEN eTestMode := TEST_ACCEL; bSetControlWord := TRUE; ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT, msgFmtStr := 'Testing acceleration...', strArg := '');
				END_IF 				
			3: 
				IF bTestDecel_Success THEN stepTestMode := stepTestMode+1; 
				ELSE eTestMode := TEST_DECEL; ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT, msgFmtStr := 'Testing deceleration...', strArg := '');
				END_IF
			4: 
				IF bTestLimits_Success THEN stepTestMode := stepTestMode+1;
				ELSE eTestMode := TEST_LIMITS; ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT, msgFmtStr := 'Testing limits...', strArg := '');
				END_IF				
			
			5: //all tests successful
				MAIN.Controlword := 0;
				ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'All tests successful!',
					strArg := '');
				stepTestMode := 0; //idle
		END_CASE	
	
		
	(* Error handling *)
	ERROR:
		MAIN.Controlword := 0;
		bSetControlWord := FALSE;
		IF bAckError THEN
			bAckError := FALSE;
			bError := FALSE;
			
			eTestMode := WAIT_FOR_TEST;
			stepTestMode := 0;
		END_IF


	READ_DEFAULT_VALUES: 
		CASE step OF
			1: //read acc
				ReadAcc(nDeltaSpeed := nDefaultAccSpeed, nDeltaTime := nDefaultAccTime, bDone => bDone);
				IF bDone THEN
					step := step+1;
				END_IF
			2: //read dec
				ReadDec(nDeltaSpeed := nDefaultDecSpeed, nDeltaTime := nDefaultDecTime, bDone => bDone);
				IF bDone THEN
					step := step+1;
				END_IF				
			3: //read limits
				ReadVelocityLimits(nVelocityMinLimit := nDefaultVelocityMinLimit, nVelocityMaxLimit := nDefaultVelocityMaxLimit, bDone => bDone);
				IF bDone THEN
					step := step+1;
				END_IF
			4: 
				eTestMode := WAIT_FOR_TEST;			
				ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'Default values read.',
					strArg := '');
		END_CASE
		
		
	WRITE_DEFAULT_VALUES: 
		CASE step OF
			1: //write acc
				WriteAcc(nDeltaSpeedRef := nDefaultAccSpeed, nDeltaTimeRef := nDefaultAccTime, bDone => bDone);
				IF bDone THEN
					step := step+1;
				END_IF
			2: 
				ReadAcc(nDeltaSpeed := nSpeed, nDeltaTime := nTime, bDone => bDone);
				IF nSpeed = nDefaultAccSpeed AND nTime = nDefaultAccTime AND bDone THEN
					step := step+1;
				END_IF
			3: //write dec
				WriteDec(nDeltaSpeedRef := nDefaultDecSpeed, nDeltaTimeRef := nDefaultDecTime, bDone => bDone);
				IF bDone THEN
					step := step+1;
				END_IF	
			4:
				ReadDec(nDeltaSpeed := nSpeed, nDeltaTime := nTime, bDone => bDone);
				IF nSpeed = nDefaultDecSpeed AND nTime = nDefaultDecTime AND bDone THEN
					step := step+1;
				END_IF
			
			5: //write limits
				WriteVelocityLimits(nVelocityMinLimit := nDefaultVelocityMinLimit, nVelocityMaxLimit := nDefaultVelocityMaxLimit, bDone => bDone);
				IF bDone THEN
					step := step+1;
				END_IF
			6: 
				ReadVelocityLimits(nVelocityMinLimit := nVelocityMinLimit, nVelocityMaxLimit := nVelocityMaxLimit, bDone => bDone);
				IF nVelocityMinLimit = nDefaultVelocityMinLimit AND nVelocityMaxLimit = nDefaultVelocityMaxLimit AND bDone THEN
					step := step+1;
				END_IF

			7: 
				eTestMode := WAIT_FOR_TEST;	
				ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'Default values restored.',
					strArg := '');		
				IF bATestFailed THEN
					bError := TRUE;
				END_IF
				IF bStopAfterLimitTest THEN
					bStopAfterLimitTest := FALSE;
					eTestMode := STOP_DRIVE;
				END_IF
		END_CASE
		
		
	STOP_DRIVE:
		step := 1;
		nTargetVelocity := 0;
		bSetVelocity := TRUE;
		fbVelocityMode(sNetID := GVL.sNetId,
					nSlaveAddr := GVL.nSlaveAddr,
					nTargetVelocity := nTargetVelocity,
					bSetVelocity := bSetVelocity,
					nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
		IF nActualVelocity = 0 THEN
			IF bWriteDefaultValues THEN
				bWriteDefaultValues := FALSE;
				eTestMode := WRITE_DEFAULT_VALUES;
			ELSE
				eTestMode := WAIT_FOR_TEST;
			END_IF
		END_IF
	
	(* Test basic operation *)
	BASIC_OPERATION:
		tTimeout(IN := TRUE, PT := T#15S);
		CASE step OF
		1:	
			nTargetVelocity := 300; //rpm
			bSetVelocity := TRUE;
			fbVelocityMode(sNetID := GVL.sNetId,
						nSlaveAddr := GVL.nSlaveAddr,
						nTargetVelocity := nTargetVelocity,
						bSetVelocity := bSetVelocity,
						nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
			IF NOT fbVelocityMode.bBusy THEN //now velocity is set
				step := step+1;
			END_IF
			
		2:  
			IF nActualVelocity > (0.98*nTargetVelocityAfterLimit) AND nActualVelocity < (1.02*nTargetVelocityAfterLimit) THEN // Vsoll = Vist
				fbGetVelocityDemand(sNetId := GVL.sNetId,
					nSlaveAddr := GVL.nSlaveAddr,
					nIndex := 16#6043,
					nSubIndex := 0,
					pDstBuf := ADR(nVelocityDemand),
					cbBufLen := SIZEOF(nVelocityDemand),
					bExecute := TRUE);
				fFlag(CLK := fbGetVelocityDemand.bBusy);
				IF fFlag.Q THEN
					IF nVelocityDemand = nTargetVelocityAfterLimit THEN
						bObject6043tested := TRUE; //vl velocity demand
						bTestBasicOperation_Success := TRUE; //set success indication	
						step := step+1;								
						ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
							msgFmtStr := 'Basic operation test success.',
							strArg := '');
					END_IF
				END_IF
			END_IF	
			
		3:	//soft stop motor
			eTestMode := STOP_DRIVE;			
		END_CASE
		
		//Error handling in wait_for_test
		IF tTimeout.Q THEN
			bTestBasicOperation_Failed := TRUE;
			bError := TRUE;
			bTimeout := FALSE;
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
				msgFmtStr := 'Basic operation test failed. Timeout.',
				strArg := '');
		END_IF

	
	(* Test acceleration target *)
	TEST_ACCEL:
		tTimeout(IN := TRUE, PT := T#15S); 
		CASE step OF
			1: //set acceleration values
				WriteAcc(nDeltaSpeedRef := nDeltaSpeedRef, nDeltaTimeRef := nDeltaTimeRef, bDone => bDone);
				IF bDone THEN
					step := step+1;
				END_IF
				
			2: //read acceleration
				ReadAcc(nDeltaSpeed := nSpeed, nDeltaTime := nTime, bDone => bDone); 
				IF nSpeed = nDeltaSpeedRef AND nTime = nDeltaTimeRef AND bDone THEN //Acceleration values were set correctly
					step := step+1;
				END_IF
				
			3: //set drive to TargetVelocity and measure acceleration time
				nTargetVelocity := 2000;
				nDeltaVelocityTarget := 1900; //needs to be a little lower than target
				fDesiredAcceleration := TO_REAL(nDeltaSpeedRef/nDeltaTimeRef); // acc reference
				
				bSetVelocity := TRUE;
				fbVelocityMode(sNetID := GVL.sNetId,
							nSlaveAddr := GVL.nSlaveAddr,
							nTargetVelocity := nTargetVelocity,
							bSetVelocity := bSetVelocity,
							nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
				fTrigger(CLK := fbVelocityMode.bBusy);
				IF fTrigger.Q THEN
					tTimeAcc1 := TIME();
					step := step+1;
				END_IF
			
			4:
				tTimer(IN:=TRUE, PT:=T#50MS);
				IF tTimer.Q THEN
					tTimer(IN:=FALSE);
					step := step+1;
				END_IF
				
			5:
				IF nActualVelocity >= nDeltaVelocityTarget THEN
					tTimeAcc2 := TIME();
					tDiff := tTimeAcc2 - tTimeAcc1; //time difference of drive to reach nSpeedRef
					tempTimeDiff := TIME_TO_DINT(tDiff);
					nAccMeasured := TO_REAL(nActualVelocity*1000/TIME_TO_DINT(tDiff)); //time in ms
					step := step+1;
				END_IF

			6: //validate result
				IF nAccMeasured > ((1-fTolerance)*fDesiredAcceleration) AND nAccMeasured < ((1+fTolerance)*fDesiredAcceleration) THEN //within range of tolerance: default 5%
					bTestAccel_Success := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'Acceleration test success.',
					strArg := '');
				ELSE
					bTestAccel_Failed := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
						msgFmtStr := 'Acceleration test failed. Motor acceleration not within range of reference values.',
						strArg := '');
				END_IF
				bWriteDefaultValues := TRUE;
				eTestMode := STOP_DRIVE; //stop and restore default variables
		END_CASE
		
		//Error handling timeout
		IF tTimeout.Q THEN
			eTestMode := WRITE_DEFAULT_VALUES; //restore default variables
			bTestAccel_Failed := TRUE;
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
				msgFmtStr := 'Acceleration test failed. Timeout.',
				strArg := '');
		END_IF
		
	
		
(* Test acceleration target *)
	TEST_DECEL:
		tTimeout(IN := TRUE, PT := T#15S); 
		CASE step OF
			1: //set deceleration values
				WriteDec(nDeltaSpeedRef := nDeltaSpeedRef, nDeltaTimeRef := nDeltaTimeRef, bDone => bDone);
				IF bDone THEN
					step := step+1;
				END_IF
				
			2: //read deceleration
				ReadDec(nDeltaSpeed := nSpeed, nDeltaTime := nTime, bDone => bDone); 
				IF nSpeed = nDeltaSpeedRef AND nTime = nDeltaTimeRef AND bDone THEN //Acceleration values were set correctly
					step := step+1;
				END_IF
				
			3: //set drive to velocity
				nTargetVelocity := 1500;
				nDecVelocity := nTargetVelocity;	
				fDesiredDeceleration := TO_REAL(nDeltaSpeedRef/nDeltaTimeRef); // dec reference		
				bSetVelocity := TRUE;
				fbVelocityMode(sNetID := GVL.sNetId,
							nSlaveAddr := GVL.nSlaveAddr,
							nTargetVelocity := nTargetVelocity,
							bSetVelocity := bSetVelocity,
							nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
				tTimer(IN:=TRUE, PT:=T#500MS);
				IF tTimer.Q THEN
					tTimer(IN:=FALSE);
					step := step+1;
				END_IF
			
			4:
				IF nActualVelocity > 0.99*nTargetVelocityAfterLimit THEN 
					nTargetVelocity := 0;
					step := step+1;
				END_IF

			5: //test run of drive for validation of deceleration 
				bSetVelocity := TRUE;
				fbVelocityMode(sNetID := GVL.sNetId,
							nSlaveAddr := GVL.nSlaveAddr,
							nTargetVelocity := nTargetVelocity,
							bSetVelocity := bSetVelocity,
							nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
				fTrigger(CLK := fbVelocityMode.bBusy);
				IF fTrigger.Q THEN
					tTimeDec1 := TIME();
					step := step+1;
				END_IF
				
			6:
				IF nActualVelocity = nTargetVelocity THEN
					tTimeDec2 := TIME();
					tDiff := tTimeDec2 - tTimeDec1; //time difference of drive to decelerate
					nDecMeasured := TO_REAL(nDecVelocity*1000/TIME_TO_DINT(tDiff));
					step := step+1;
				END_IF
			
			7:	//validation
				IF nDecMeasured > ((1-fTolerance)*fDesiredDeceleration) AND nDecMeasured < ((1+fTolerance)*fDesiredDeceleration) THEN //within range of tolerance: default 5%
					bTestDecel_Success := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'Deceleration test success.',
					strArg := '');
				ELSE
					bTestDecel_Failed := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_WARN,
						msgFmtStr := 'Deceleration test failed. Motor deceleration not within range of reference values.',
						strArg := '');
				END_IF
				bWriteDefaultValues := TRUE;
				eTestMode := STOP_DRIVE; //stop and restore default variables
		END_CASE
		
		//Error handling timeout
		IF tTimeout.Q THEN
			eTestMode := WRITE_DEFAULT_VALUES; //restore default variables
			bTestDecel_Failed := TRUE;
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_WARN,
				msgFmtStr := 'Deceleration test failed. Timeout.',
				strArg := '');
		END_IF
		

	
//	(* Test velocity limtis *)
	TEST_LIMITS: 
		tTimeout(IN:=TRUE, PT:=T#15S);
		CASE step OF
			1: 
				nTargetVelocity := 2000;
				WriteVelocityLimits(nVelocityMinLimit := nMinLimitRef, nVelocityMaxLimit := nMaxLimitRef, bDone => bDone);
				IF bDone THEN
					step := step+1;
				END_IF
				
			2: //test max limit
				bSetVelocity := TRUE;
				fbVelocityMode(sNetID := GVL.sNetId,
							nSlaveAddr := GVL.nSlaveAddr,
							nTargetVelocity := nTargetVelocity,
							bSetVelocity := bSetVelocity,
							nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
				IF NOT fbVelocityMode.bBusy THEN
					bIsAccelerating := TRUE;
					step := step+1;
				END_IF
			
			3:
				tTimer(IN := bIsAccelerating, PT := T#3S); //run for x seconds
				IF tTimer.Q THEN 
					tTimer(IN:=FALSE);
					step := step+1;
				END_IF
			
			4:
				IF nActualVelocity > (1.10*nMaxLimitRef)(* 10% overshot accounted *) THEN 
					bMaxLimitTest_Failed := TRUE;
					eTestMode := WRITE_DEFAULT_VALUES;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_WARN,
						msgFmtStr := 'Max limit test failed.',
						strArg := '');			
				ELSE
					bMaxLimitTest_Success := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
						msgFmtStr := 'Max limit test success.',
						strArg := '');
					step := step+1;
				END_IF
				bIsAccelerating := FALSE;
				
			5: //test min limit
				nTargetVelocity := 0;
				bSetVelocity := TRUE;
				fbVelocityMode(sNetID := GVL.sNetId,
							nSlaveAddr := GVL.nSlaveAddr,
							nTargetVelocity := nTargetVelocity,
							bSetVelocity := bSetVelocity,
							nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
				IF NOT fbVelocityMode.bBusy THEN
					bIsDecelerating := TRUE;
					step := step+1;
				END_IF
								
			6:
				tTimer(IN := bIsDecelerating, PT := T#3S); //run for x seconds
				IF tTimer.Q THEN 
					step := step+1;
				END_IF
			
			7:
//				fTimeFaktor := DINT_TO_REAL((nActualVelocity-nTargetVelocity)/nSpeedDec); 
//				tDecTime := REAL_TO_TIME(2000+fTimeFaktor * nDefaultDecTime*1000); //acceleration time, min 2s
//				tTimer(IN := bIsDecelerating, PT := tDecTime);
//				//error if limit does not apply
				IF nActualVelocity < (0.9*nMinLimitRef)(*10% overshot accounted*) THEN 
					bMinLimitTest_Failed := TRUE;
					eTestMode := WRITE_DEFAULT_VALUES;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_WARN,
						msgFmtStr := 'Min limit test failed.',
						strArg := '');										
				ELSIF tTimer.Q THEN //time at witch the drive would be on targetvelocity without limit acitve
					bMinLimitTest_Success := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
						msgFmtStr := 'Min limit test success.',
						strArg := '');
					step := step+1;
				END_IF
				bIsDecelerating := FALSE;
			
			8:
				IF bMinLimitTest_Success AND bMaxLimitTest_Success THEN
					bTestLimits_Success := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
						msgFmtStr := 'Limit test success.',
						strArg := '');
				ELSE
					bTestLimits_Failed := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
						msgFmtStr := 'Limit test failed.',
						strArg := '');
				END_IF
				bStopAfterLimitTest := TRUE;
				step := 1;
				eTestMode := WRITE_DEFAULT_VALUES; //stop and restore default variables				
		END_CASE

END_CASE













]]></ST>
    </Implementation>
    <Method Name="ReadAcc" Id="{82ba7047-c692-4533-849f-64295ad386ce}">
      <Declaration><![CDATA[METHOD ReadAcc : BOOL
VAR_IN_OUT
	nDeltaSpeed 	: DINT;
	nDeltaTime 		: DINT;
	//bRead : BOOL;
END_VAR
VAR_OUTPUT
	bDone			: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bDone := FALSE;
//IF bRead THEN
	fbReadAcc1(sNetId := GVL.sNetId,
				nSlaveAddr := GVL.nSlaveAddr,
				nIndex := 16#6048,
				nSubindex := 1, //delta speed
				pDstBuf := ADR(nDeltaSpeed),
				cbBufLen := SIZEOF(nDeltaSpeed),
				bExecute := TRUE);
	
	fbReadAcc2(sNetId := GVL.sNetId,
				nSlaveAddr := GVL.nSlaveAddr,
				nIndex := 16#6048,
				nSubindex := 2, //delta time
				pDstBuf := ADR(nDeltaTime),
				cbBufLen := SIZEOF(nDeltaTime),
				bExecute := TRUE);
//END_IF
IF NOT fbReadAcc1.bBusy AND NOT fbReadAcc2.bBusy THEN
	fbReadAcc1(bExecute := FALSE); 
	fbReadAcc2(bExecute := FALSE); 
	//bRead := FALSE;
	bDone := TRUE;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadDec" Id="{0557ec76-04b4-48e4-983c-7a14a262e28c}">
      <Declaration><![CDATA[METHOD ReadDec : BOOL
VAR_IN_OUT
	nDeltaSpeed 	: DINT;
	nDeltaTime 		: DINT;
END_VAR
VAR_OUTPUT
	bDone			: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bDone := FALSE;
fbReadDec1(sNetId := GVL.sNetId,
			nSlaveAddr := GVL.nSlaveAddr,
			nIndex := 16#6049,
			nSubindex := 1, //delta speed
			pDstBuf := ADR(nDeltaSpeed),
			cbBufLen := SIZEOF(nDeltaSpeed),
			bExecute := TRUE);

fbReadDec2(sNetId := GVL.sNetId,
			nSlaveAddr := GVL.nSlaveAddr,
			nIndex := 16#6049,
			nSubindex := 2, //delta time
			pDstBuf := ADR(nDeltaTime),
			cbBufLen := SIZEOF(nDeltaTime),
			bExecute := TRUE);

IF NOT fbReadDec1.bBusy AND NOT fbReadDec2.bBusy THEN
	fbReadDec1(bExecute := FALSE); 
	fbReadDec2(bExecute := FALSE); 
	bDone := TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadVelocityLimits" Id="{6c32334b-6bd8-4afb-bf3f-0b7a4b269db0}">
      <Declaration><![CDATA[METHOD ReadVelocityLimits : BOOL
VAR_IN_OUT
	nVelocityMinLimit 	: DINT;
	nVelocityMaxLimit 	: DINT;
END_VAR
VAR_OUTPUT
	bDone			: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[bDone := FALSE;
	fbReadVelocityLimits1(sNetId := GVL.sNetId,
			nSlaveAddr := GVL.nSlaveAddr,
			nIndex := 16#6046,
			nSubindex := 1, //v_min
			pDstBuf := ADR(nVelocityMinLimit),
			cbBufLen := SIZEOF(nVelocityMinLimit),
			bExecute := TRUE);
	
	fbReadVelocityLimits2(sNetId := GVL.sNetId,
			nSlaveAddr := GVL.nSlaveAddr,
			nIndex := 16#6046,
			nSubindex := 2, //v_max
			pDstBuf := ADR(nVelocityMaxLimit),
			cbBufLen := SIZEOF(nVelocityMaxLimit),
			bExecute := TRUE);
			
IF NOT fbReadVelocityLimits1.bBusy AND NOT fbReadVelocityLimits2.bBusy THEN
	fbReadVelocityLimits1(bExecute := FALSE); 
	fbReadVelocityLimits2(bExecute := FALSE); 
	bDone := TRUE;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteAcc" Id="{1f9b3a2d-c64b-462e-ac9f-355827bafb38}">
      <Declaration><![CDATA[METHOD WriteAcc : BOOL
VAR_IN_OUT
	nDeltaSpeedRef	: DINT;
	nDeltaTimeRef	: DINT;
END_VAR
VAR_OUTPUT
	bDone 			: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bDone := FALSE;
fbWriteAcc1(sNetId := GVL.sNetId,
		nSlaveAddr := GVL.nSlaveAddr,
		nIndex := 16#6048,
		nSubindex := 1, //delta speed
		pSrcBuf := ADR(nDeltaSpeedRef),
		cbBufLen := SIZEOF(nDeltaSpeedRef),
		bExecute := TRUE);	
			
fbWriteAcc2(sNetId := GVL.sNetId,
		nSlaveAddr := GVL.nSlaveAddr,
		nIndex := 16#6048,
		nSubindex := 2, //delta time
		pSrcBuf := ADR(nDeltaTimeRef),
		cbBufLen := SIZEOF(nDeltaTimeRef),
		bExecute := TRUE);

IF NOT fbWriteAcc1.bBusy AND NOT fbWriteAcc2.bBusy THEN
	fbWriteAcc1(bExecute := FALSE); 
	fbWriteAcc2(bExecute := FALSE); 
	bDone := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteDec" Id="{3e991329-f862-4f37-bc95-f9bc8420fcb7}">
      <Declaration><![CDATA[METHOD WriteDec : BOOL
VAR_IN_OUT
	nDeltaSpeedRef	: DINT;
	nDeltaTimeRef	: DINT;
END_VAR
VAR_OUTPUT
	bDone 			: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bDone := FALSE;
fbWriteDec1(sNetId := GVL.sNetId,
		nSlaveAddr := GVL.nSlaveAddr,
		nIndex := 16#6049,
		nSubindex := 1, //delta speed
		pSrcBuf := ADR(nDeltaSpeedRef),
		cbBufLen := SIZEOF(nDeltaSpeedRef),
		bExecute := TRUE);	
			
fbWriteDec2(sNetId := GVL.sNetId,
		nSlaveAddr := GVL.nSlaveAddr,
		nIndex := 16#6049,
		nSubindex := 2, //delta time
		pSrcBuf := ADR(nDeltaTimeRef),
		cbBufLen := SIZEOF(nDeltaTimeRef),
		bExecute := TRUE);
			
IF NOT fbWriteDec1.bBusy AND NOT fbWriteDec2.bBusy THEN
	fbWriteDec1(bExecute := FALSE); 
	fbWriteDec2(bExecute := FALSE); 
	bDone := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteVelocityLimits" Id="{0e00e114-68f4-4bc1-81e9-c2d6f626f095}">
      <Declaration><![CDATA[METHOD WriteVelocityLimits : BOOL
VAR_IN_OUT
	nVelocityMinLimit 	: DINT;
	nVelocityMaxLimit 	: DINT;
END_VAR
VAR_OUTPUT
	bDone			: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[bDone := FALSE;
	fbWriteVelocityLimits1(sNetId := GVL.sNetId,
			nSlaveAddr := GVL.nSlaveAddr,
			nIndex := 16#6046,
			nSubindex := 1, //v_min
			pSrcBuf := ADR(nVelocityMinLimit),
			cbBufLen := SIZEOF(nVelocityMinLimit),
			bExecute := TRUE);
	
	fbWriteVelocityLimits2(sNetId := GVL.sNetId,
			nSlaveAddr := GVL.nSlaveAddr,
			nIndex := 16#6046,
			nSubindex := 2, //v_max
			pSrcBuf := ADR(nVelocityMaxLimit),
			cbBufLen := SIZEOF(nVelocityMaxLimit),
			bExecute := TRUE);
			
IF NOT fbWriteVelocityLimits1.bBusy AND NOT fbWriteVelocityLimits2.bBusy THEN
	fbWriteVelocityLimits1(bExecute := FALSE); 
	fbWriteVelocityLimits2(bExecute := FALSE); 
	bDone := TRUE;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="P_VelocityModeTest">
      <LineId Id="6085" Count="0" />
      <LineId Id="6088" Count="0" />
      <LineId Id="6090" Count="0" />
      <LineId Id="6089" Count="0" />
      <LineId Id="6086" Count="1" />
      <LineId Id="4740" Count="35" />
      <LineId Id="5490" Count="0" />
      <LineId Id="4776" Count="9" />
      <LineId Id="6100" Count="1" />
      <LineId Id="4786" Count="0" />
      <LineId Id="4789" Count="6" />
      <LineId Id="6343" Count="0" />
      <LineId Id="4796" Count="6" />
      <LineId Id="6137" Count="0" />
      <LineId Id="4804" Count="2" />
      <LineId Id="6140" Count="0" />
      <LineId Id="4808" Count="1" />
      <LineId Id="6147" Count="0" />
      <LineId Id="6143" Count="0" />
      <LineId Id="4812" Count="1" />
      <LineId Id="6133" Count="0" />
      <LineId Id="4814" Count="2" />
      <LineId Id="6342" Count="0" />
      <LineId Id="4818" Count="13" />
      <LineId Id="5701" Count="0" />
      <LineId Id="5745" Count="18" />
      <LineId Id="5791" Count="2" />
      <LineId Id="5764" Count="1" />
      <LineId Id="5785" Count="1" />
      <LineId Id="5766" Count="6" />
      <LineId Id="6108" Count="4" />
      <LineId Id="5773" Count="4" />
      <LineId Id="6115" Count="3" />
      <LineId Id="6114" Count="0" />
      <LineId Id="6113" Count="0" />
      <LineId Id="5778" Count="4" />
      <LineId Id="6121" Count="3" />
      <LineId Id="5783" Count="0" />
      <LineId Id="6120" Count="0" />
      <LineId Id="6119" Count="0" />
      <LineId Id="5788" Count="2" />
      <LineId Id="5784" Count="0" />
      <LineId Id="6081" Count="2" />
      <LineId Id="6335" Count="0" />
      <LineId Id="6340" Count="0" />
      <LineId Id="6336" Count="1" />
      <LineId Id="5706" Count="0" />
      <LineId Id="4832" Count="0" />
      <LineId Id="5676" Count="0" />
      <LineId Id="4833" Count="0" />
      <LineId Id="5971" Count="0" />
      <LineId Id="6093" Count="0" />
      <LineId Id="5671" Count="4" />
      <LineId Id="5669" Count="1" />
      <LineId Id="5800" Count="0" />
      <LineId Id="5803" Count="0" />
      <LineId Id="5801" Count="0" />
      <LineId Id="5804" Count="1" />
      <LineId Id="5802" Count="0" />
      <LineId Id="5678" Count="0" />
      <LineId Id="5668" Count="0" />
      <LineId Id="4834" Count="1" />
      <LineId Id="5847" Count="0" />
      <LineId Id="4836" Count="6" />
      <LineId Id="6169" Count="0" />
      <LineId Id="4844" Count="1" />
      <LineId Id="5630" Count="0" />
      <LineId Id="5810" Count="1" />
      <LineId Id="4849" Count="0" />
      <LineId Id="4855" Count="0" />
      <LineId Id="5830" Count="10" />
      <LineId Id="5843" Count="3" />
      <LineId Id="5841" Count="1" />
      <LineId Id="4860" Count="1" />
      <LineId Id="5491" Count="1" />
      <LineId Id="4862" Count="1" />
      <LineId Id="5692" Count="0" />
      <LineId Id="4864" Count="12" />
      <LineId Id="6038" Count="0" />
      <LineId Id="4877" Count="0" />
      <LineId Id="5166" Count="0" />
      <LineId Id="4885" Count="0" />
      <LineId Id="5373" Count="2" />
      <LineId Id="5172" Count="0" />
      <LineId Id="5171" Count="0" />
      <LineId Id="4886" Count="3" />
      <LineId Id="4892" Count="2" />
      <LineId Id="5507" Count="0" />
      <LineId Id="5509" Count="1" />
      <LineId Id="4895" Count="5" />
      <LineId Id="5162" Count="0" />
      <LineId Id="4902" Count="1" />
      <LineId Id="6097" Count="0" />
      <LineId Id="4904" Count="0" />
      <LineId Id="6098" Count="1" />
      <LineId Id="6102" Count="0" />
      <LineId Id="6104" Count="0" />
      <LineId Id="6156" Count="0" />
      <LineId Id="6105" Count="2" />
      <LineId Id="6103" Count="0" />
      <LineId Id="4905" Count="2" />
      <LineId Id="5487" Count="0" />
      <LineId Id="4908" Count="1" />
      <LineId Id="6096" Count="0" />
      <LineId Id="4911" Count="12" />
      <LineId Id="5798" Count="0" />
      <LineId Id="4924" Count="0" />
      <LineId Id="4945" Count="3" />
      <LineId Id="5787" Count="0" />
      <LineId Id="5794" Count="2" />
      <LineId Id="4950" Count="3" />
      <LineId Id="5972" Count="0" />
      <LineId Id="5974" Count="1" />
      <LineId Id="6039" Count="0" />
      <LineId Id="5976" Count="1" />
      <LineId Id="5979" Count="11" />
      <LineId Id="6315" Count="0" />
      <LineId Id="6059" Count="0" />
      <LineId Id="6078" Count="0" />
      <LineId Id="5995" Count="5" />
      <LineId Id="6150" Count="1" />
      <LineId Id="6157" Count="0" />
      <LineId Id="6152" Count="3" />
      <LineId Id="6040" Count="0" />
      <LineId Id="6313" Count="0" />
      <LineId Id="6041" Count="0" />
      <LineId Id="6011" Count="1" />
      <LineId Id="6042" Count="0" />
      <LineId Id="6044" Count="8" />
      <LineId Id="6317" Count="0" />
      <LineId Id="6053" Count="0" />
      <LineId Id="6318" Count="0" />
      <LineId Id="6316" Count="0" />
      <LineId Id="6054" Count="4" />
      <LineId Id="6026" Count="0" />
      <LineId Id="6061" Count="0" />
      <LineId Id="6077" Count="0" />
      <LineId Id="6064" Count="10" />
      <LineId Id="6080" Count="0" />
      <LineId Id="6062" Count="0" />
      <LineId Id="6027" Count="8" />
      <LineId Id="5973" Count="0" />
      <LineId Id="6036" Count="0" />
      <LineId Id="5040" Count="3" />
      <LineId Id="6128" Count="0" />
      <LineId Id="5045" Count="0" />
      <LineId Id="5049" Count="0" />
      <LineId Id="6178" Count="0" />
      <LineId Id="6129" Count="0" />
      <LineId Id="5050" Count="0" />
      <LineId Id="6160" Count="0" />
      <LineId Id="6162" Count="0" />
      <LineId Id="5057" Count="1" />
      <LineId Id="5060" Count="5" />
      <LineId Id="5067" Count="1" />
      <LineId Id="6163" Count="0" />
      <LineId Id="5069" Count="0" />
      <LineId Id="6164" Count="1" />
      <LineId Id="5072" Count="0" />
      <LineId Id="6179" Count="0" />
      <LineId Id="6328" Count="0" />
      <LineId Id="6180" Count="3" />
      <LineId Id="5073" Count="0" />
      <LineId Id="5075" Count="3" />
      <LineId Id="5081" Count="0" />
      <LineId Id="5085" Count="6" />
      <LineId Id="6185" Count="0" />
      <LineId Id="5092" Count="8" />
      <LineId Id="5102" Count="1" />
      <LineId Id="6327" Count="0" />
      <LineId Id="5104" Count="0" />
      <LineId Id="6319" Count="0" />
      <LineId Id="6322" Count="3" />
      <LineId Id="6320" Count="0" />
      <LineId Id="6326" Count="0" />
      <LineId Id="6329" Count="0" />
      <LineId Id="5105" Count="5" />
      <LineId Id="6149" Count="0" />
      <LineId Id="5112" Count="2" />
      <LineId Id="5119" Count="0" />
      <LineId Id="5121" Count="5" />
      <LineId Id="6330" Count="0" />
      <LineId Id="5127" Count="8" />
      <LineId Id="5137" Count="2" />
      <LineId Id="6333" Count="0" />
      <LineId Id="6339" Count="0" />
      <LineId Id="6341" Count="0" />
      <LineId Id="5140" Count="0" />
      <LineId Id="5142" Count="0" />
      <LineId Id="5147" Count="14" />
      <LineId Id="829" Count="0" />
    </LineIds>
    <LineIds Name="P_VelocityModeTest.ReadAcc">
      <LineId Id="122" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="35" Count="4" />
      <LineId Id="41" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="64" Count="6" />
      <LineId Id="92" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="114" Count="1" />
      <LineId Id="111" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="100" Count="0" />
    </LineIds>
    <LineIds Name="P_VelocityModeTest.ReadDec">
      <LineId Id="29" Count="0" />
      <LineId Id="31" Count="18" />
      <LineId Id="51" Count="1" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="P_VelocityModeTest.ReadVelocityLimits">
      <LineId Id="143" Count="0" />
      <LineId Id="174" Count="5" />
      <LineId Id="151" Count="1" />
      <LineId Id="180" Count="5" />
      <LineId Id="159" Count="0" />
      <LineId Id="186" Count="0" />
      <LineId Id="161" Count="2" />
      <LineId Id="165" Count="1" />
      <LineId Id="131" Count="0" />
      <LineId Id="81" Count="0" />
    </LineIds>
    <LineIds Name="P_VelocityModeTest.WriteAcc">
      <LineId Id="39" Count="0" />
      <LineId Id="7" Count="6" />
      <LineId Id="21" Count="0" />
      <LineId Id="15" Count="5" />
      <LineId Id="5" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="30" Count="2" />
      <LineId Id="38" Count="0" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="P_VelocityModeTest.WriteDec">
      <LineId Id="35" Count="20" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="P_VelocityModeTest.WriteVelocityLimits">
      <LineId Id="62" Count="22" />
      <LineId Id="24" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>