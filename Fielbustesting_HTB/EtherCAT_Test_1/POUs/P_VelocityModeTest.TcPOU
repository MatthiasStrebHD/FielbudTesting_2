<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="P_VelocityModeTest" Id="{20dbc57a-bcdc-4d5e-be58-5c2d209d0155}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM P_VelocityModeTest
VAR
	fbVelocityMode					: VelocityMode;
	fbGetStatusword					: FB_EcCoeSdoRead;
	fbGetActualVelocity				: FB_EcCoeSdoRead;
	fbGetVelocityLimitMax			: FB_EcCoeSdoRead;
	fbGetVelocityLimitMin			: FB_EcCoeSdoRead;
	fbReadAcc						: FB_EcCoeSdoRead;
	fbWriteAcc						: FB_EcCoESdoWrite;
	fbReadDec						: FB_EcCoeSdoRead;
	fbWriteDec						: FB_EcCoESdoWrite;
	nTargetVelocity					: DINT := 50; //rpm
	nActualVelocity					: DINT;
	nVelocityLimitMax				: DINT;
	nVelocityLimitMin				: DINT;
	nStatusword						: UINT;
	nDefaultSpeed					: DINT;
	nDefaultTime					: DINT;
	nSpeed							: DINT;
	nTime							: DINT;
	nDeltaSpeedRef					: DINT := 300; //rpm
	nDeltaTimeRef					: DINT := 1;
	nAccRef							: DINT;
		
	tWaitForCurrentVelocity			: TON;
	bGetCurrentVelocity				: BOOL;
	tGetStatusword					: TON;
	bGetStatusword					: BOOL;
	bSetVelocity					: BOOL; 
	nTargetVelocityAfterLimit		: DINT;
END_VAR

//test case variables
VAR
	bStartTest				: BOOL; //TODO delete for automatic run through tests
	tTimeout				: TON;
	tTimeAcc1				: TIME;
	tTimeAcc2				: TIME;
	tDiff					: TIME;
	fTrigger				: F_TRIG;
	
	eTestMode				: (WAIT_FOR_TEST, ERROR, BASIC_OPERATION, TEST_ACCEL, TEST_DECEL, TEST_LIMITS); 
	nStep					: INT := 1;
	nTestModeStep			: INT := 1;
END_VAR


//test case success indication variables
VAR
	bError							: BOOL := FALSE;
	bTestBasicOperation_Success		: BOOL := FALSE;
	bTestBasicOperation_Failed		: BOOL := FALSE;
	bTestAccel_Success				: BOOL := FALSE;
	bTestAccel_Failed				: BOOL := FALSE;
	bTestDecel_Success				: BOOL := FALSE;
	bTestDecel_Failed				: BOOL := FALSE;
	bTestLimits_Success				: BOOL := FALSE;
	bTestLimits_Failed				: BOOL := FALSE;
END_VAR

//Error handling
VAR
	bStopMotor						: BOOL;
	bSetControlWord					: BOOL := TRUE;
	bAckError						: BOOL;
	bRestartTest					: BOOL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[tWaitForCurrentVelocity(IN := bGetCurrentVelocity,
							PT := T#10MS);
tGetStatusword(IN := bGetStatusword,
					PT := T#500MS);	
							
IF tWaitForCurrentVelocity.Q THEN
	bGetCurrentVelocity := FALSE;
ELSE
	bGetCurrentVelocity := TRUE;		
END_IF
// read FBs
fbGetStatusword(sNetId := GVL.sNetId,
				nSlaveAddr := GVL.nSlaveAddr,
				nIndex := 16#6041,
				nSubindex := 0,
				pDstBuf := ADR(nStatusWord),
				cbBufLen := SIZEOF(nStatusWord),
				bExecute := bGetStatusword);
				
fbGetActualVelocity(sNetId := GVL.sNetId,
					nSlaveAddr := GVL.nSlaveAddr,
					nIndex := 16#6044,
					nSubindex := 0,
					pDstBuf := ADR(nActualVelocity),
					cbBufLen := SIZEOF(nActualVelocity),
					bExecute := bGetCurrentVelocity);

//write to motor
MAIN.Controlword.4 := bSetControlWord; //velocity demand value shall equal to ramp output value
MAIN.Controlword.5 := bSetControlWord; //ramp output value shall follow ramp input value
MAIN.Controlword.6 := bSetControlWord; //ramp input value shall accord with ramp reference

			
//stop
IF bStopMotor OR bError THEN
	MAIN.Controlword := 0;
END_IF


(*TEST SUITE*)
CASE eTestMode OF
	WAIT_FOR_TEST:	
		CASE nTestModeStep OF
			-1: //error handling
				eTestMode := ERROR;
			0: //idle
				IF bRestartTest THEN
					bRestartTest := FALSE;
					nTestModeStep := nTestModeStep+1;
				END_IF				
			1: 
				eTestMode := BASIC_OPERATION;
				IF bTestBasicOperation_Success THEN nTestModeStep := nTestModeStep+1; END_IF
			2: 
				eTestMode := TEST_ACCEL;
				IF bTestAccel_Success THEN nTestModeStep := nTestModeStep+1; END_IF
			3: 
				eTestMode := TEST_DECEL;
				IF bTestDecel_Success THEN nTestModeStep := nTestModeStep+1; END_IF
			4: 
				eTestMode := TEST_LIMITS;
				IF bTestLimits_Success THEN nTestModeStep := nTestModeStep+1; END_IF
			
			5: //all tests successful
				ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'All tests successful!',
					strArg := '');
		END_CASE	
		nStep := 1; //resetting general step counter for use within TestModes
	
		
	(* Error handling *)
	ERROR:
		bError := TRUE;
		MAIN.Controlword := 0;
		IF bAckError THEN
			bAckError := FALSE;
			bError := FALSE;
			
			eTestMode := WAIT_FOR_TEST;
			nTestModeStep := 1;
		END_IF
		
		
	(* Test basic operation *)
	BASIC_OPERATION:
		nTargetVelocity := 300; //rpm
		bSetVelocity := TRUE;
		fbVelocityMode(sNetID := GVL.sNetId,
					nSlaveAddr := GVL.nSlaveAddr,
					nTargetVelocity := nTargetVelocity,
					bSetVelocity := bSetVelocity,
					nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
		IF NOT fbVelocityMode.bBusy THEN //now velocity is set
			tTimeout(IN := TRUE, PT := T#15S);
			IF nActualVelocity = nTargetVelocityAfterLimit THEN // Vsoll = Vist
				bTestBasicOperation_Success := TRUE; //set success indication
				eTestMode := WAIT_FOR_TEST;
				
				MAIN.Controlword := 0;
				ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'Basic operation test success.',
					strArg := '');
			END_IF
			
			//Error handling in wait_for_test
			IF tTimeout.Q THEN
				bTestBasicOperation_Failed := TRUE;
				nTestModeStep := -1;
				eTestMode := WAIT_FOR_TEST;
				ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'Basic operation test failed. Timeout.',
					strArg := '');
			END_IF
		END_IF 

		
	(* Test acceleration target *)
	TEST_ACCEL:
		CASE nStep OF
			1: //store acceleration values
				ReadAcc(nDeltaSpeed => nDefaultSpeed, nDeltaTime => nDefaultTime);
				nStep := nStep+1;
				
			2: //set acceleration values
				WriteAcc(nDeltaSpeedRef := nDeltaSpeedRef, nDeltaTimeRef := nDeltaTimeRef);
						// TODO at the moment unused
						IF nDeltaSpeedRef>0 AND nDeltaTimeRef>0 THEN 
							nAccRef := nDeltaSpeedRef / nDeltaTimeRef;
						END_IF
				ReadAcc(nDeltaSpeed => nSpeed, nDeltaTime => nTime); //read drive and check if acc was set correctly
					// TODO delete is a test case because the hardware is not available
					nSpeed := nDeltaSpeedRef;
					nTime := nDeltaTimeRef;
				IF nSpeed = nDeltaSpeedRef AND nTime = nDeltaTimeRef THEN //Acceleration values were set correctly
					nStep := nStep+1;
				END_IF
				
			3: //test run of drive for validation of acceleration 
				nTargetVelocity := 1500;
				bSetVelocity := TRUE;
				fbVelocityMode(sNetID := GVL.sNetId,
							nSlaveAddr := GVL.nSlaveAddr,
							nTargetVelocity := nTargetVelocity,
							bSetVelocity := bSetVelocity,
							nTargetVelocityAfterLimit => nTargetVelocityAfterLimit);
				fTrigger(CLK := fbVelocityMode.bBusy);
				IF fTrigger.Q THEN
					tTimeAcc1 := TIME();
				END_IF
				IF nActualVelocity >= nDeltaSpeedRef THEN
					tTimeAcc2 := TIME();
					tDiff := tTimeAcc2 - tTimeAcc1; //time difference of drive to reach nSpeedRef
					nStep := nStep+1;
				END_IF

			4: //validate result
				IF TIME_TO_DINT(tDiff) > (0.9*nDeltaTimeRef) AND TIME_TO_DINT(tDiff) < (1.1*nDeltaTimeRef) THEN //within range of 10% of desired time 
					bTestAccel_Success := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'Acceleration test success.',
					strArg := '');
				ELSE
					bTestAccel_Failed := TRUE;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
					msgFmtStr := 'Acceleration test failed. Reference margin of acceleration was not reached by motor.',
					strArg := '');
				END_IF
				nStep := nStep+1;
			
			5: //set default variables back to standard
				WriteAcc(nDeltaSpeedRef := nDefaultSpeed, nDeltaTimeRef := nDefaultTime);
				ReadAcc(nDeltaSpeed => nSpeed, nDeltaTime => nTime); //read drive 
				IF nSpeed = nDefaultSpeed AND nTime = nDefaultTime THEN //Acceleration values were set correctly to default values
					eTestMode := WAIT_FOR_TEST;
					ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT,
						msgFmtStr := 'Default values restored.',
						strArg := '');
						
					IF bTestAccel_Failed THEN
						nTestModeStep := -1;						
					END_IF
				END_IF		
		END_CASE
	
	
	(* Test velocity limtis *)
	TEST_LIMITS: 
		//get limits
		fbGetVelocityLimitMax(sNetId := GVL.sNetID,
					nSlaveAddr := GVL.nSlaveAddr,
					nSubIndex := 2, //v_max
					nIndex := 16#6046, 
					pDstBuf := ADR(nVelocityLimitMax),
					cbBufLen := SIZEOF(nVelocityLimitMax),
					bExecute := TRUE);
		fbGetVelocityLimitMin(sNetId := GVL.sNetID,
					nSlaveAddr := GVL.nSlaveAddr,
					nSubIndex := 1, //v_min
					nIndex := 16#6046, 
					pDstBuf := ADR(nVelocityLimitMin),
					cbBufLen := SIZEOF(nVelocityLimitMin),
					bExecute := TRUE);

		



END_CASE













]]></ST>
    </Implementation>
    <Method Name="ReadAcc" Id="{82ba7047-c692-4533-849f-64295ad386ce}">
      <Declaration><![CDATA[METHOD ReadAcc : BOOL
VAR_OUTPUT
	nDeltaSpeed 	: DINT;
	nDeltaTime 		: DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbReadAcc(sNetId := GVL.sNetId,
				nSlaveAddr := GVL.nSlaveAddr,
				nIndex := 16#6048,
				nSubindex := 1, //delta speed
				pDstBuf := ADR(nDeltaSpeed),
				cbBufLen := SIZEOF(nDeltaSpeed),
				bExecute := TRUE);
				
fbReadAcc(bExecute := FALSE);		
fbReadAcc(sNetId := GVL.sNetId,
		nSlaveAddr := GVL.nSlaveAddr,
		nIndex := 16#6048,
		nSubindex := 2, //delta time
		pDstBuf := ADR(nDeltaTime),
		cbBufLen := SIZEOF(nDeltaTime),
		bExecute := TRUE);
fbReadAcc(bExecute := FALSE);]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadDec" Id="{0557ec76-04b4-48e4-983c-7a14a262e28c}">
      <Declaration><![CDATA[METHOD ReadDec : BOOL
VAR_OUTPUT
	nDeltaSpeed 	: DINT;
	nDeltaTime 	: DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbReadDec(sNetId := GVL.sNetId,
				nSlaveAddr := GVL.nSlaveAddr,
				nIndex := 16#6049,
				nSubindex := 1, //delta speed
				pDstBuf := ADR(nDeltaSpeed),
				cbBufLen := SIZEOF(nDeltaSpeed),
				bExecute := TRUE);
				
fbReadDec(bExecute := FALSE);		
fbReadDec(sNetId := GVL.sNetId,
		nSlaveAddr := GVL.nSlaveAddr,
		nIndex := 16#6049,
		nSubindex := 2, //delta time
		pDstBuf := ADR(nDeltaTime),
		cbBufLen := SIZEOF(nDeltaTime),
		bExecute := TRUE);
fbReadDec(bExecute := FALSE);]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteAcc" Id="{1f9b3a2d-c64b-462e-ac9f-355827bafb38}">
      <Declaration><![CDATA[METHOD WriteAcc : BOOL
VAR_INPUT
	nDeltaSpeedRef	: DINT;
	nDeltaTimeRef	: DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbWriteAcc(sNetId := GVL.sNetId,
		nSlaveAddr := GVL.nSlaveAddr,
		nIndex := 16#6048,
		nSubindex := 1, //delta speed
		pSrcBuf := ADR(nDeltaSpeedRef),
		cbBufLen := SIZEOF(nDeltaSpeedRef),
		bExecute := TRUE);	
fbWriteAcc(bExecute := FALSE);
			
fbWriteAcc(sNetId := GVL.sNetId,
		nSlaveAddr := GVL.nSlaveAddr,
		nIndex := 16#6048,
		nSubindex := 2, //delta time
		pSrcBuf := ADR(nDeltaTimeRef),
		cbBufLen := SIZEOF(nDeltaTimeRef),
		bExecute := TRUE);
fbWriteAcc(bExecute := FALSE);
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="P_VelocityModeTest">
      <LineId Id="2861" Count="57" />
      <LineId Id="3089" Count="0" />
      <LineId Id="2919" Count="1" />
      <LineId Id="3098" Count="1" />
      <LineId Id="3104" Count="0" />
      <LineId Id="3101" Count="0" />
      <LineId Id="3103" Count="0" />
      <LineId Id="3100" Count="0" />
      <LineId Id="2921" Count="154" />
      <LineId Id="829" Count="0" />
    </LineIds>
    <LineIds Name="P_VelocityModeTest.ReadAcc">
      <LineId Id="34" Count="15" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="P_VelocityModeTest.ReadDec">
      <LineId Id="6" Count="14" />
      <LineId Id="5" Count="0" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="P_VelocityModeTest.WriteAcc">
      <LineId Id="7" Count="7" />
      <LineId Id="21" Count="0" />
      <LineId Id="15" Count="5" />
      <LineId Id="5" Count="0" />
      <LineId Id="22" Count="1" />
    </LineIds>
  </POU>
</TcPlcObject>